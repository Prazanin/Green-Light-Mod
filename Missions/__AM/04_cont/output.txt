// export MissionStart ; export debug ; starting var nul ; begin debug := false ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// RandomizeAll ;
   8: CALL_OW 11
// InGameOn ;
  12: CALL_OW 8
// LoadVariables ;
  16: CALL 5938 0 0
// InitiateConstants ;
  20: CALL 10688 0 0
// PrepareDifficulty ;
  24: CALL 10768 0 0
// KathrynOrderAttack := false ;
  28: LD_ADDR_EXP 41
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// KathrynAttackStance := 2 ;
  36: LD_ADDR_EXP 42
  40: PUSH
  41: LD_INT 2
  43: ST_TO_ADDR
// KathrynLostControl := false ;
  44: LD_ADDR_EXP 43
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// KathrynMood := 100 ;
  52: LD_ADDR_EXP 45
  56: PUSH
  57: LD_INT 100
  59: ST_TO_ADDR
// KathrynStatus := 0 ;
  60: LD_ADDR_EXP 46
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// ReachedBase := false ;
  68: LD_ADDR_EXP 3
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// CreatePersonas ;
  76: CALL 2774 0 0
// Garrison_Buildings ( 3 ) ;
  80: LD_INT 3
  82: PPUSH
  83: CALL 5994 0 1
// Garrison_Buildings ( 6 ) ;
  87: LD_INT 6
  89: PPUSH
  90: CALL 5994 0 1
// Assemble_Barracks ( 3 ) ;
  94: LD_INT 3
  96: PPUSH
  97: CALL 6739 0 1
// Assemble_Armories ( 3 ) ;
 101: LD_INT 3
 103: PPUSH
 104: CALL 7027 0 1
// Assemble_Armories ( 6 ) ;
 108: LD_INT 6
 110: PPUSH
 111: CALL 7027 0 1
// Fill_Bunkers ( 3 ) ;
 115: LD_INT 3
 117: PPUSH
 118: CALL 7418 0 1
// Fill_Bunkers ( 6 ) ;
 122: LD_INT 6
 124: PPUSH
 125: CALL 7418 0 1
// Fill_Turrets ( 3 ) ;
 129: LD_INT 3
 131: PPUSH
 132: CALL 7579 0 1
// Fill_Turrets ( 6 ) ;
 136: LD_INT 6
 138: PPUSH
 139: CALL 7579 0 1
// if Difficulty = 1 then
 143: LD_OWVAR 67
 147: PUSH
 148: LD_INT 1
 150: EQUAL
 151: IFFALSE 235
// begin RussianMobile ( 3 , 3 , 0 , RU1Base1Area ) ;
 153: LD_INT 3
 155: PPUSH
 156: LD_INT 3
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 3
 164: PPUSH
 165: CALL 7684 0 4
// RussianMobile ( 3 , 4 , 1 , RU1Base2Area ) ;
 169: LD_INT 3
 171: PPUSH
 172: LD_INT 4
 174: PPUSH
 175: LD_INT 1
 177: PPUSH
 178: LD_INT 4
 180: PPUSH
 181: CALL 7684 0 4
// RussianMobile ( 3 , 3 , 2 , RU1Base3Area ) ;
 185: LD_INT 3
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: LD_INT 2
 193: PPUSH
 194: LD_INT 5
 196: PPUSH
 197: CALL 7684 0 4
// RussianMobile ( 6 , 2 , 0 , RU2Base1Area ) ;
 201: LD_INT 6
 203: PPUSH
 204: LD_INT 2
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: LD_INT 6
 212: PPUSH
 213: CALL 7684 0 4
// RussianMobile ( 6 , 3 , 0 , RU2Base2Area ) ;
 217: LD_INT 6
 219: PPUSH
 220: LD_INT 3
 222: PPUSH
 223: LD_INT 0
 225: PPUSH
 226: LD_INT 7
 228: PPUSH
 229: CALL 7684 0 4
// end else
 233: GO 417
// if Difficulty = 2 then
 235: LD_OWVAR 67
 239: PUSH
 240: LD_INT 2
 242: EQUAL
 243: IFFALSE 327
// begin RussianMobile ( 3 , 4 , 0 , RU1Base1Area ) ;
 245: LD_INT 3
 247: PPUSH
 248: LD_INT 4
 250: PPUSH
 251: LD_INT 0
 253: PPUSH
 254: LD_INT 3
 256: PPUSH
 257: CALL 7684 0 4
// RussianMobile ( 3 , 3 , 2 , RU1Base2Area ) ;
 261: LD_INT 3
 263: PPUSH
 264: LD_INT 3
 266: PPUSH
 267: LD_INT 2
 269: PPUSH
 270: LD_INT 4
 272: PPUSH
 273: CALL 7684 0 4
// RussianMobile ( 3 , 1 , 4 , RU1Base3Area ) ;
 277: LD_INT 3
 279: PPUSH
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 4
 285: PPUSH
 286: LD_INT 5
 288: PPUSH
 289: CALL 7684 0 4
// RussianMobile ( 6 , 3 , 0 , RU2Base1Area ) ;
 293: LD_INT 6
 295: PPUSH
 296: LD_INT 3
 298: PPUSH
 299: LD_INT 0
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 7684 0 4
// RussianMobile ( 6 , 3 , 1 , RU2Base2Area ) ;
 309: LD_INT 6
 311: PPUSH
 312: LD_INT 3
 314: PPUSH
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 7
 320: PPUSH
 321: CALL 7684 0 4
// end else
 325: GO 417
// if Difficulty = 3 then
 327: LD_OWVAR 67
 331: PUSH
 332: LD_INT 3
 334: EQUAL
 335: IFFALSE 417
// begin RussianMobile ( 3 , 4 , 1 , RU1Base1Area ) ;
 337: LD_INT 3
 339: PPUSH
 340: LD_INT 4
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: LD_INT 3
 348: PPUSH
 349: CALL 7684 0 4
// RussianMobile ( 3 , 2 , 3 , RU1Base2Area ) ;
 353: LD_INT 3
 355: PPUSH
 356: LD_INT 2
 358: PPUSH
 359: LD_INT 3
 361: PPUSH
 362: LD_INT 4
 364: PPUSH
 365: CALL 7684 0 4
// RussianMobile ( 3 , 0 , 5 , RU1Base3Area ) ;
 369: LD_INT 3
 371: PPUSH
 372: LD_INT 0
 374: PPUSH
 375: LD_INT 5
 377: PPUSH
 378: LD_INT 5
 380: PPUSH
 381: CALL 7684 0 4
// RussianMobile ( 6 , 3 , 1 , RU2Base1Area ) ;
 385: LD_INT 6
 387: PPUSH
 388: LD_INT 3
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: LD_INT 6
 396: PPUSH
 397: CALL 7684 0 4
// RussianMobile ( 6 , 3 , 2 , RU2Base2Area ) ;
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 3
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: LD_INT 7
 412: PPUSH
 413: CALL 7684 0 4
// end ; Squad_Assembly ;
 417: CALL 4400 0 0
// Kathryn_Squad_Assembly ;
 421: CALL 5409 0 0
// CenterNowOnXY ( 179 , 286 ) ;
 425: LD_INT 179
 427: PPUSH
 428: LD_INT 286
 430: PPUSH
 431: CALL_OW 86
// DWait ( 0 0$1 ) ;
 435: LD_INT 35
 437: PPUSH
 438: CALL_OW 68
// Say ( Miller , D2-Miller-1 ) ;
 442: LD_EXP 8
 446: PPUSH
 447: LD_STRING D2-Miller-1
 449: PPUSH
 450: CALL_OW 88
// Say ( Simone , D2-Simone-1 ) ;
 454: LD_EXP 6
 458: PPUSH
 459: LD_STRING D2-Simone-1
 461: PPUSH
 462: CALL_OW 88
// CenterOnXY ( 237 , 281 ) ;
 466: LD_INT 237
 468: PPUSH
 469: LD_INT 281
 471: PPUSH
 472: CALL_OW 84
// DWait ( 0 0$1 ) ;
 476: LD_INT 35
 478: PPUSH
 479: CALL_OW 68
// Say ( Simone , D2-Simone-2 ) ;
 483: LD_EXP 6
 487: PPUSH
 488: LD_STRING D2-Simone-2
 490: PPUSH
 491: CALL_OW 88
// SayRadio ( Kathryn , D2-Kathryn-1 ) ;
 495: LD_EXP 7
 499: PPUSH
 500: LD_STRING D2-Kathryn-1
 502: PPUSH
 503: CALL_OW 94
// CenterOnXY ( 179 , 286 ) ;
 507: LD_INT 179
 509: PPUSH
 510: LD_INT 286
 512: PPUSH
 513: CALL_OW 84
// DWait ( 0 0$1 ) ;
 517: LD_INT 35
 519: PPUSH
 520: CALL_OW 68
// Say ( Simone , D2-Simone-3 ) ;
 524: LD_EXP 6
 528: PPUSH
 529: LD_STRING D2-Simone-3
 531: PPUSH
 532: CALL_OW 88
// DWait ( 0 0$1 ) ;
 536: LD_INT 35
 538: PPUSH
 539: CALL_OW 68
// nul = Query ( QKathryn ) ;
 543: LD_ADDR_VAR 0 1
 547: PUSH
 548: LD_STRING QKathryn
 550: PPUSH
 551: CALL_OW 97
 555: ST_TO_ADDR
// ChangeMissionObjectives ( M1 ) ;
 556: LD_STRING M1
 558: PPUSH
 559: CALL_OW 337
// InGameOff ;
 563: CALL_OW 9
// MissionStart := true ;
 567: LD_ADDR_EXP 1
 571: PUSH
 572: LD_INT 1
 574: ST_TO_ADDR
// SaveForQuickRestart ;
 575: CALL_OW 22
// HintSpec ( Kathryn , 3 ) ;
 579: LD_STRING Kathryn
 581: PPUSH
 582: LD_INT 3
 584: PPUSH
 585: CALL_OW 338
// KathrynStatus := 1 ;
 589: LD_ADDR_EXP 46
 593: PUSH
 594: LD_INT 1
 596: ST_TO_ADDR
// KathrynScript ;
 597: CALL 11657 0 0
// end ;
 601: END
// export ReachedBase ; every 0 0$1 trigger not ReachedBase and FilterUnitsInArea ( RU1MainBaseArea , [ f_side , 7 ] ) > 0 do var Speaker , filter , filter2 ;
 602: LD_EXP 3
 606: NOT
 607: PUSH
 608: LD_INT 11
 610: PPUSH
 611: LD_INT 22
 613: PUSH
 614: LD_INT 7
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: PPUSH
 621: CALL_OW 70
 625: PUSH
 626: LD_INT 0
 628: GREATER
 629: AND
 630: IFFALSE 2030
 632: GO 634
 634: DISABLE
 635: LD_INT 0
 637: PPUSH
 638: PPUSH
 639: PPUSH
// begin enable ;
 640: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) <= 1 and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
 641: LD_INT 22
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 2
 653: PUSH
 654: LD_INT 30
 656: PUSH
 657: LD_INT 0
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: PUSH
 664: LD_INT 30
 666: PUSH
 667: LD_INT 1
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL_OW 69
 687: PUSH
 688: LD_INT 1
 690: LESSEQUAL
 691: NOT
 692: PUSH
 693: LD_INT 22
 695: PUSH
 696: LD_INT 6
 698: PUSH
 699: EMPTY
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 30
 708: PUSH
 709: LD_INT 0
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 30
 718: PUSH
 719: LD_INT 1
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: EMPTY
 727: LIST
 728: LIST
 729: LIST
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: PPUSH
 735: CALL_OW 69
 739: PUSH
 740: LD_INT 0
 742: EQUAL
 743: NOT
 744: AND
 745: IFFALSE 926
// begin DialogueOn ;
 747: CALL_OW 6
// interface_hidden := true ;
 751: LD_ADDR_OWVAR 54
 755: PUSH
 756: LD_INT 1
 758: ST_TO_ADDR
// Say ( Miller , D5-Miller-1 ) ;
 759: LD_EXP 8
 763: PPUSH
 764: LD_STRING D5-Miller-1
 766: PPUSH
 767: CALL_OW 88
// DialogueOff ;
 771: CALL_OW 7
// CenterOnUnits ( filter [ 1 ] ) ;
 775: LD_VAR 0 2
 779: PUSH
 780: LD_INT 1
 782: ARRAY
 783: PPUSH
 784: CALL_OW 85
// filter := FilterUnitsInArea ( RU1MainBaseArea , [ f_side , 7 ] ) ;
 788: LD_ADDR_VAR 0 2
 792: PUSH
 793: LD_INT 11
 795: PPUSH
 796: LD_INT 22
 798: PUSH
 799: LD_INT 7
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 70
 810: ST_TO_ADDR
// filter2 := FilterUnitsInArea ( RU1MainBaseAreaStopUnits , [ f_side , 7 ] ) ;
 811: LD_ADDR_VAR 0 3
 815: PUSH
 816: LD_INT 13
 818: PPUSH
 819: LD_INT 22
 821: PUSH
 822: LD_INT 7
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: PPUSH
 829: CALL_OW 70
 833: ST_TO_ADDR
// RemoveTasks ( filter2 ) ;
 834: LD_VAR 0 3
 838: PPUSH
 839: CALL_OW 493
// ComMoveXY ( filter , ShiftX ( GetX ( filter [ 1 ] ) , 3 , 8 ) , ShiftY ( GetY ( filter [ 1 ] ) , 3 , 8 ) ) ;
 843: LD_VAR 0 2
 847: PPUSH
 848: LD_VAR 0 2
 852: PUSH
 853: LD_INT 1
 855: ARRAY
 856: PPUSH
 857: CALL_OW 250
 861: PPUSH
 862: LD_INT 3
 864: PPUSH
 865: LD_INT 8
 867: PPUSH
 868: CALL_OW 272
 872: PPUSH
 873: LD_VAR 0 2
 877: PUSH
 878: LD_INT 1
 880: ARRAY
 881: PPUSH
 882: CALL_OW 251
 886: PPUSH
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 8
 892: PPUSH
 893: CALL_OW 273
 897: PPUSH
 898: CALL_OW 111
// Wait ( 0 0$5 ) ;
 902: LD_INT 175
 904: PPUSH
 905: CALL_OW 67
// interface_hidden := false ;
 909: LD_ADDR_OWVAR 54
 913: PUSH
 914: LD_INT 0
 916: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
 917: LD_INT 175
 919: PPUSH
 920: CALL_OW 67
// end else
 924: GO 2030
// begin InGameOn ;
 926: CALL_OW 8
// ReachedBase := true ;
 930: LD_ADDR_EXP 3
 934: PUSH
 935: LD_INT 1
 937: ST_TO_ADDR
// disable ;
 938: DISABLE
// if FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) > 9 then
 939: LD_INT 22
 941: PUSH
 942: LD_INT 4
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 21
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: PPUSH
 963: CALL_OW 69
 967: PUSH
 968: LD_INT 9
 970: GREATER
 971: IFFALSE 981
// KathrynHalfForcesRemaining := true ;
 973: LD_ADDR_EXP 44
 977: PUSH
 978: LD_INT 1
 980: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 4 ] ) , 150 , 118 ) ;
 981: LD_INT 22
 983: PUSH
 984: LD_INT 4
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: PPUSH
 991: CALL_OW 69
 995: PPUSH
 996: LD_INT 150
 998: PPUSH
 999: LD_INT 118
1001: PPUSH
1002: CALL_OW 111
// RemoveTasks ( FilterAllUnits ( [ f_side , 7 ] ) ) ;
1006: LD_INT 22
1008: PUSH
1009: LD_INT 7
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL_OW 69
1020: PPUSH
1021: CALL_OW 493
// Speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff [ Miller , Pravar , Simone ] ;
1025: LD_ADDR_VAR 0 1
1029: PUSH
1030: LD_INT 22
1032: PUSH
1033: LD_INT 7
1035: PUSH
1036: EMPTY
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 2
1042: PUSH
1043: LD_INT 25
1045: PUSH
1046: LD_INT 1
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 25
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 25
1065: PUSH
1066: LD_INT 3
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: PUSH
1073: LD_INT 25
1075: PUSH
1076: LD_INT 4
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 25
1085: PUSH
1086: LD_INT 5
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: PUSH
1093: EMPTY
1094: LIST
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: EMPTY
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL_OW 69
1109: PUSH
1110: LD_EXP 8
1114: PUSH
1115: LD_EXP 9
1119: PUSH
1120: LD_EXP 6
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: DIFF
1130: ST_TO_ADDR
// RevealFogArea ( 7 , RU1MainBaseDefenses ) ;
1131: LD_INT 7
1133: PPUSH
1134: LD_INT 12
1136: PPUSH
1137: CALL_OW 332
// CenterOnXY ( 118 , 43 ) ;
1141: LD_INT 118
1143: PPUSH
1144: LD_INT 43
1146: PPUSH
1147: CALL_OW 84
// Say ( Simone , D6-Simone-1 ) ;
1151: LD_EXP 6
1155: PPUSH
1156: LD_STRING D6-Simone-1
1158: PPUSH
1159: CALL_OW 88
// CenterOnXY ( 69 , 9 ) ;
1163: LD_INT 69
1165: PPUSH
1166: LD_INT 9
1168: PPUSH
1169: CALL_OW 84
// SaySex ( Speaker [ Rand ( 1 , Speaker ) ] , D6-Sol-1 , D6-FemSol-1 ) ;
1173: LD_VAR 0 1
1177: PUSH
1178: LD_INT 1
1180: PPUSH
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 12
1190: ARRAY
1191: PPUSH
1192: LD_STRING D6-Sol-1
1194: PPUSH
1195: LD_STRING D6-FemSol-1
1197: PPUSH
1198: CALL 10137 0 3
// PlaceUnitXYR ( Micoyan , 101 , 16 , 2 , false ) ;
1202: LD_EXP 14
1206: PPUSH
1207: LD_INT 101
1209: PPUSH
1210: LD_INT 16
1212: PPUSH
1213: LD_INT 2
1215: PPUSH
1216: LD_INT 0
1218: PPUSH
1219: CALL_OW 50
// PlaceSeeing ( 101 , 16 , 7 , 9 ) ;
1223: LD_INT 101
1225: PPUSH
1226: LD_INT 16
1228: PPUSH
1229: LD_INT 7
1231: PPUSH
1232: LD_INT 9
1234: PPUSH
1235: CALL_OW 330
// CenterOnXY ( 101 , 16 ) ;
1239: LD_INT 101
1241: PPUSH
1242: LD_INT 16
1244: PPUSH
1245: CALL_OW 84
// DWait ( 0 0$2 ) ;
1249: LD_INT 70
1251: PPUSH
1252: CALL_OW 68
// SayRadio ( Micoyan , D7-Micoyan-1 ) ;
1256: LD_EXP 14
1260: PPUSH
1261: LD_STRING D7-Micoyan-1
1263: PPUSH
1264: CALL_OW 94
// SayRadio ( Sidorovich , D7-Sidor-1 ) ;
1268: LD_EXP 13
1272: PPUSH
1273: LD_STRING D7-Sidor-1
1275: PPUSH
1276: CALL_OW 94
// SayRadio ( Micoyan , D7-Micoyan-2 ) ;
1280: LD_EXP 14
1284: PPUSH
1285: LD_STRING D7-Micoyan-2
1287: PPUSH
1288: CALL_OW 94
// DWait ( 0 0$2 ) ;
1292: LD_INT 70
1294: PPUSH
1295: CALL_OW 68
// SayRadio ( Kathryn , D8-Kathryn-1 ) ;
1299: LD_EXP 7
1303: PPUSH
1304: LD_STRING D8-Kathryn-1
1306: PPUSH
1307: CALL_OW 94
// SayRadio ( Sidorovich , D8-Sidor-1 ) ;
1311: LD_EXP 13
1315: PPUSH
1316: LD_STRING D8-Sidor-1
1318: PPUSH
1319: CALL_OW 94
// Say ( Simone , D8-Simone-1 ) ;
1323: LD_EXP 6
1327: PPUSH
1328: LD_STRING D8-Simone-1
1330: PPUSH
1331: CALL_OW 88
// Say ( Miller , D8-Miller-1 ) ;
1335: LD_EXP 8
1339: PPUSH
1340: LD_STRING D8-Miller-1
1342: PPUSH
1343: CALL_OW 88
// Say ( Simone , D8-Simone-2 ) ;
1347: LD_EXP 6
1351: PPUSH
1352: LD_STRING D8-Simone-2
1354: PPUSH
1355: CALL_OW 88
// RemoveSeeing ( 101 , 16 , 7 ) ;
1359: LD_INT 101
1361: PPUSH
1362: LD_INT 16
1364: PPUSH
1365: LD_INT 7
1367: PPUSH
1368: CALL_OW 331
// CenterOnUnits ( Kathryn ) ;
1372: LD_EXP 7
1376: PPUSH
1377: CALL_OW 85
// CenterOnUnits ( IsInUnit ( Kathryn ) ) ;
1381: LD_EXP 7
1385: PPUSH
1386: CALL_OW 310
1390: PPUSH
1391: CALL_OW 85
// SayRadio ( Kathryn , D8-Kathryn-2 ) ;
1395: LD_EXP 7
1399: PPUSH
1400: LD_STRING D8-Kathryn-2
1402: PPUSH
1403: CALL_OW 94
// Say ( Simone , D8-Simone-3 ) ;
1407: LD_EXP 6
1411: PPUSH
1412: LD_STRING D8-Simone-3
1414: PPUSH
1415: CALL_OW 88
// SayRadio ( Kathryn , D8-Kathryn-3 ) ;
1419: LD_EXP 7
1423: PPUSH
1424: LD_STRING D8-Kathryn-3
1426: PPUSH
1427: CALL_OW 94
// ComAgressiveMove ( KathrynSquad , 101 , 20 ) ;
1431: LD_EXP 21
1435: PPUSH
1436: LD_INT 101
1438: PPUSH
1439: LD_INT 20
1441: PPUSH
1442: CALL_OW 114
// ComAgressiveMove ( Kathryn , 101 , 20 ) ;
1446: LD_EXP 7
1450: PPUSH
1451: LD_INT 101
1453: PPUSH
1454: LD_INT 20
1456: PPUSH
1457: CALL_OW 114
// ComAgressiveMove ( IsInUnit ( Kathryn ) , 101 , 20 ) ;
1461: LD_EXP 7
1465: PPUSH
1466: CALL_OW 310
1470: PPUSH
1471: LD_INT 101
1473: PPUSH
1474: LD_INT 20
1476: PPUSH
1477: CALL_OW 114
// Say ( Simone , D8-Simone-4 ) ;
1481: LD_EXP 6
1485: PPUSH
1486: LD_STRING D8-Simone-4
1488: PPUSH
1489: CALL_OW 88
// CenterOnUnits ( Kathryn ) ;
1493: LD_EXP 7
1497: PPUSH
1498: CALL_OW 85
// CenterOnUnits ( IsInUnit ( Kathryn ) ) ;
1502: LD_EXP 7
1506: PPUSH
1507: CALL_OW 310
1511: PPUSH
1512: CALL_OW 85
// SayRadio ( Kathryn , D8-Kathryn-4 ) ;
1516: LD_EXP 7
1520: PPUSH
1521: LD_STRING D8-Kathryn-4
1523: PPUSH
1524: CALL_OW 94
// DoNotAttack ( 3 , Kathryn ) ;
1528: LD_INT 3
1530: PPUSH
1531: LD_EXP 7
1535: PPUSH
1536: CALL_OW 471
// CenterOnXY ( 121 , 52 ) ;
1540: LD_INT 121
1542: PPUSH
1543: LD_INT 52
1545: PPUSH
1546: CALL_OW 84
// music_class := 5 ;
1550: LD_ADDR_OWVAR 72
1554: PUSH
1555: LD_INT 5
1557: ST_TO_ADDR
// Wait ( 0 0$15 ) ;
1558: LD_INT 525
1560: PPUSH
1561: CALL_OW 67
// Say ( Kathryn , D8-Kathryn-5 ) ;
1565: LD_EXP 7
1569: PPUSH
1570: LD_STRING D8-Kathryn-5
1572: PPUSH
1573: CALL_OW 88
// SayRadio ( Micoyan , D8a-Micoyan-1 ) ;
1577: LD_EXP 14
1581: PPUSH
1582: LD_STRING D8a-Micoyan-1
1584: PPUSH
1585: CALL_OW 94
// Wait ( 0 0$10 ) ;
1589: LD_INT 350
1591: PPUSH
1592: CALL_OW 67
// Say ( Kathryn , D8a-Kathryn-1 ) ;
1596: LD_EXP 7
1600: PPUSH
1601: LD_STRING D8a-Kathryn-1
1603: PPUSH
1604: CALL_OW 88
// Wait ( 0 0$15 ) ;
1608: LD_INT 525
1610: PPUSH
1611: CALL_OW 67
// Say ( Heisenberg , D8a-Heisenberg-1 ) ;
1615: LD_EXP 16
1619: PPUSH
1620: LD_STRING D8a-Heisenberg-1
1622: PPUSH
1623: CALL_OW 88
// ComMoveToArea ( FilterAllUnits ( [ f_side , 4 ] ) diff Kathryn , KatParking3 ) ;
1627: LD_INT 22
1629: PUSH
1630: LD_INT 4
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PPUSH
1637: CALL_OW 69
1641: PUSH
1642: LD_EXP 7
1646: DIFF
1647: PPUSH
1648: LD_INT 18
1650: PPUSH
1651: CALL_OW 113
// NormalAttack ( 3 , Kathryn ) ;
1655: LD_INT 3
1657: PPUSH
1658: LD_EXP 7
1662: PPUSH
1663: CALL_OW 472
// Say ( Kathryn , D8a-Kathryn-1a ) ;
1667: LD_EXP 7
1671: PPUSH
1672: LD_STRING D8a-Kathryn-1a
1674: PPUSH
1675: CALL_OW 88
// repeat wait ( 3 ) ;
1679: LD_INT 3
1681: PPUSH
1682: CALL_OW 67
// ComAttackUnit ( Kathryn , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , Kathryn ) ) ;
1686: LD_EXP 7
1690: PPUSH
1691: LD_INT 22
1693: PUSH
1694: LD_INT 3
1696: PUSH
1697: EMPTY
1698: LIST
1699: LIST
1700: PPUSH
1701: CALL_OW 69
1705: PPUSH
1706: LD_EXP 7
1710: PPUSH
1711: CALL_OW 74
1715: PPUSH
1716: CALL_OW 115
// until IsDying ( Kathryn ) or IsDead ( Kathryn ) ;
1720: LD_EXP 7
1724: PPUSH
1725: CALL_OW 303
1729: PUSH
1730: LD_EXP 7
1734: PPUSH
1735: CALL_OW 301
1739: OR
1740: IFFALSE 1679
// ForceSay ( Kathryn , D8a-Kathryn-2 ) ;
1742: LD_EXP 7
1746: PPUSH
1747: LD_STRING D8a-Kathryn-2
1749: PPUSH
1750: CALL_OW 91
// Say ( Simone , D8a-Simone-1 ) ;
1754: LD_EXP 6
1758: PPUSH
1759: LD_STRING D8a-Simone-1
1761: PPUSH
1762: CALL_OW 88
// Wait ( 0 0$2 ) ;
1766: LD_INT 70
1768: PPUSH
1769: CALL_OW 67
// Say ( Simone , D8a-Simone-2 ) ;
1773: LD_EXP 6
1777: PPUSH
1778: LD_STRING D8a-Simone-2
1780: PPUSH
1781: CALL_OW 88
// Wait ( 0 0$5 ) ;
1785: LD_INT 175
1787: PPUSH
1788: CALL_OW 67
// CenterOnUnits ( Simone ) ;
1792: LD_EXP 6
1796: PPUSH
1797: CALL_OW 85
// CenterOnUnits ( IsInUnit ( Simone ) ) ;
1801: LD_EXP 6
1805: PPUSH
1806: CALL_OW 310
1810: PPUSH
1811: CALL_OW 85
// SaySex ( Speaker [ Rand ( 1 , Speaker ) ] , D8b-Sol-1 , D8b-FemSol-1 ) ;
1815: LD_VAR 0 1
1819: PUSH
1820: LD_INT 1
1822: PPUSH
1823: LD_VAR 0 1
1827: PPUSH
1828: CALL_OW 12
1832: ARRAY
1833: PPUSH
1834: LD_STRING D8b-Sol-1
1836: PPUSH
1837: LD_STRING D8b-FemSol-1
1839: PPUSH
1840: CALL 10137 0 3
// Say ( Simone , D8b-Simone-1 ) ;
1844: LD_EXP 6
1848: PPUSH
1849: LD_STRING D8b-Simone-1
1851: PPUSH
1852: CALL_OW 88
// if IsOK ( Pravar ) then
1856: LD_EXP 9
1860: PPUSH
1861: CALL_OW 302
1865: IFFALSE 1965
// begin Say ( Pravar , D8b-Pravar-1 ) ;
1867: LD_EXP 9
1871: PPUSH
1872: LD_STRING D8b-Pravar-1
1874: PPUSH
1875: CALL_OW 88
// Say ( Simone , D8b-Simone-2 ) ;
1879: LD_EXP 6
1883: PPUSH
1884: LD_STRING D8b-Simone-2
1886: PPUSH
1887: CALL_OW 88
// Say ( Pravar , D8b-Pravar-2 ) ;
1891: LD_EXP 9
1895: PPUSH
1896: LD_STRING D8b-Pravar-2
1898: PPUSH
1899: CALL_OW 88
// Say ( Pravar , D8b-Pravar-3 ) ;
1903: LD_EXP 9
1907: PPUSH
1908: LD_STRING D8b-Pravar-3
1910: PPUSH
1911: CALL_OW 88
// Say ( Simone , D8b-Simone-3 ) ;
1915: LD_EXP 6
1919: PPUSH
1920: LD_STRING D8b-Simone-3
1922: PPUSH
1923: CALL_OW 88
// Say ( Miller , D8b-Miller-1 ) ;
1927: LD_EXP 8
1931: PPUSH
1932: LD_STRING D8b-Miller-1
1934: PPUSH
1935: CALL_OW 88
// Say ( Miller , D8b-Miller-1a ) ;
1939: LD_EXP 8
1943: PPUSH
1944: LD_STRING D8b-Miller-1a
1946: PPUSH
1947: CALL_OW 88
// Say ( Miller , D8b-Miller-2 ) ;
1951: LD_EXP 8
1955: PPUSH
1956: LD_STRING D8b-Miller-2
1958: PPUSH
1959: CALL_OW 88
// end else
1963: GO 1989
// begin Say ( Miller , D8b-Miller-2 ) ;
1965: LD_EXP 8
1969: PPUSH
1970: LD_STRING D8b-Miller-2
1972: PPUSH
1973: CALL_OW 88
// Say ( Miller , D8b-Miller-1a ) ;
1977: LD_EXP 8
1981: PPUSH
1982: LD_STRING D8b-Miller-1a
1984: PPUSH
1985: CALL_OW 88
// end ; ChangeMissionObjectives ( M2 ) ;
1989: LD_STRING M2
1991: PPUSH
1992: CALL_OW 337
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 7 ) ;
1996: LD_INT 22
1998: PUSH
1999: LD_INT 4
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: PPUSH
2006: CALL_OW 69
2010: PPUSH
2011: LD_INT 7
2013: PPUSH
2014: CALL_OW 235
// music_class := 0 ;
2018: LD_ADDR_OWVAR 72
2022: PUSH
2023: LD_INT 0
2025: ST_TO_ADDR
// InGameOff ;
2026: CALL_OW 9
// end ; end ;
2030: PPOPN 3
2032: END
// every 0 0$1 trigger IsDead ( behemot ) do
2033: LD_INT 208
2035: PPUSH
2036: CALL_OW 301
2040: IFFALSE 2064
2042: GO 2044
2044: DISABLE
// begin Say ( Simone , D9-Simone-1 ) ;
2045: LD_EXP 6
2049: PPUSH
2050: LD_STRING D9-Simone-1
2052: PPUSH
2053: CALL_OW 88
// ChangeMissionObjectives ( M2a ) ;
2057: LD_STRING M2a
2059: PPUSH
2060: CALL_OW 337
// end ;
2064: END
// every 0 0$1 trigger IsDead ( RUBase ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
2065: LD_INT 68
2067: PPUSH
2068: CALL_OW 301
2072: PUSH
2073: LD_INT 22
2075: PUSH
2076: LD_INT 3
2078: PUSH
2079: EMPTY
2080: LIST
2081: LIST
2082: PUSH
2083: LD_INT 21
2085: PUSH
2086: LD_INT 1
2088: PUSH
2089: EMPTY
2090: LIST
2091: LIST
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: PPUSH
2097: CALL_OW 69
2101: PUSH
2102: LD_INT 0
2104: EQUAL
2105: AND
2106: IFFALSE 2334
2108: GO 2110
2110: DISABLE
// begin InGameOn ;
2111: CALL_OW 8
// SayRadio ( Sidorovich , D9-Sidor-1 ) ;
2115: LD_EXP 13
2119: PPUSH
2120: LD_STRING D9-Sidor-1
2122: PPUSH
2123: CALL_OW 94
// Say ( Simone , D9-Simone-1a ) ;
2127: LD_EXP 6
2131: PPUSH
2132: LD_STRING D9-Simone-1a
2134: PPUSH
2135: CALL_OW 88
// DWait ( 0 0$2 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 68
// if not BradfordSecondCallout then
2146: LD_EXP 5
2150: NOT
2151: IFFALSE 2215
// begin SayRadio ( Bradford , D9-Bradford-1 ) ;
2153: LD_EXP 11
2157: PPUSH
2158: LD_STRING D9-Bradford-1
2160: PPUSH
2161: CALL_OW 94
// Say ( Simone , D9-Simone-2 ) ;
2165: LD_EXP 6
2169: PPUSH
2170: LD_STRING D9-Simone-2
2172: PPUSH
2173: CALL_OW 88
// SayRadio ( Bradford , D9-Bradford-2 ) ;
2177: LD_EXP 11
2181: PPUSH
2182: LD_STRING D9-Bradford-2
2184: PPUSH
2185: CALL_OW 94
// Say ( Simone , D9-Simone-3 ) ;
2189: LD_EXP 6
2193: PPUSH
2194: LD_STRING D9-Simone-3
2196: PPUSH
2197: CALL_OW 88
// SayRadio ( Bradford , D9-Bradford-3 ) ;
2201: LD_EXP 11
2205: PPUSH
2206: LD_STRING D9-Bradford-3
2208: PPUSH
2209: CALL_OW 94
// end else
2213: GO 2275
// begin SayRadio ( Bradford , D9-Bradford-1a ) ;
2215: LD_EXP 11
2219: PPUSH
2220: LD_STRING D9-Bradford-1a
2222: PPUSH
2223: CALL_OW 94
// Say ( Simone , D9-Simone-2a ) ;
2227: LD_EXP 6
2231: PPUSH
2232: LD_STRING D9-Simone-2a
2234: PPUSH
2235: CALL_OW 88
// SayRadio ( Bradford , D9-Bradford-2a ) ;
2239: LD_EXP 11
2243: PPUSH
2244: LD_STRING D9-Bradford-2a
2246: PPUSH
2247: CALL_OW 94
// Say ( Simone , D9-Simone-3a ) ;
2251: LD_EXP 6
2255: PPUSH
2256: LD_STRING D9-Simone-3a
2258: PPUSH
2259: CALL_OW 88
// SayRadio ( Bradford , D9-Bradford-3a ) ;
2263: LD_EXP 11
2267: PPUSH
2268: LD_STRING D9-Bradford-3a
2270: PPUSH
2271: CALL_OW 94
// end ; DWait ( 0 0$2 ) ;
2275: LD_INT 70
2277: PPUSH
2278: CALL_OW 68
// Say ( Simone , D9a-Simone-1 ) ;
2282: LD_EXP 6
2286: PPUSH
2287: LD_STRING D9a-Simone-1
2289: PPUSH
2290: CALL_OW 88
// Say ( Miller , D9a-Miller-1 ) ;
2294: LD_EXP 8
2298: PPUSH
2299: LD_STRING D9a-Miller-1
2301: PPUSH
2302: CALL_OW 88
// Say ( Simone , D9a-Simone-2 ) ;
2306: LD_EXP 6
2310: PPUSH
2311: LD_STRING D9a-Simone-2
2313: PPUSH
2314: CALL_OW 88
// Say ( Miller , D9a-Miller-2 ) ;
2318: LD_EXP 8
2322: PPUSH
2323: LD_STRING D9a-Miller-2
2325: PPUSH
2326: CALL_OW 88
// EndMission ;
2330: CALL 10188 0 0
// end ;
2334: END
// every 0 0$1 trigger MissionStart do
2335: LD_EXP 1
2339: IFFALSE 2387
2341: GO 2343
2343: DISABLE
// begin wait ( 5 5$0 ) ;
2344: LD_INT 10500
2346: PPUSH
2347: CALL_OW 67
// SayRadio ( Bradford , D4-Bradford-1 ) ;
2351: LD_EXP 11
2355: PPUSH
2356: LD_STRING D4-Bradford-1
2358: PPUSH
2359: CALL_OW 94
// Say ( Simone , D4-Simone-1 ) ;
2363: LD_EXP 6
2367: PPUSH
2368: LD_STRING D4-Simone-1
2370: PPUSH
2371: CALL_OW 88
// SayRadio ( Bradford , D4-Bradford-2 ) ;
2375: LD_EXP 11
2379: PPUSH
2380: LD_STRING D4-Bradford-2
2382: PPUSH
2383: CALL_OW 94
// end ;
2387: END
// export BradfordFirstCallout , BradfordSecondCallout ; every 0 0$1 trigger MissionStart do
2388: LD_EXP 1
2392: IFFALSE 2434
2394: GO 2396
2396: DISABLE
// begin wait ( BradfordFirstThresholdTimer ) ;
2397: LD_EXP 37
2401: PPUSH
2402: CALL_OW 67
// DialogueOn ;
2406: CALL_OW 6
// SayRadio ( Bradford , D5-Bradford-1 ) ;
2410: LD_EXP 11
2414: PPUSH
2415: LD_STRING D5-Bradford-1
2417: PPUSH
2418: CALL_OW 94
// DialogueOff ;
2422: CALL_OW 7
// BradfordFirstCallout := true ;
2426: LD_ADDR_EXP 4
2430: PUSH
2431: LD_INT 1
2433: ST_TO_ADDR
// end ;
2434: END
// every 0 0$1 trigger MissionStart do
2435: LD_EXP 1
2439: IFFALSE 2488
2441: GO 2443
2443: DISABLE
// begin wait ( BradfordSecondThresholdTimer ) ;
2444: LD_EXP 38
2448: PPUSH
2449: CALL_OW 67
// DialogueOn ;
2453: CALL_OW 6
// SayRadio ( Bradford , D5-Bradford-2 ) ;
2457: LD_EXP 11
2461: PPUSH
2462: LD_STRING D5-Bradford-2
2464: PPUSH
2465: CALL_OW 94
// DialogueOff ;
2469: CALL_OW 7
// BradfordSecondCallout := true ;
2473: LD_ADDR_EXP 5
2477: PUSH
2478: LD_INT 1
2480: ST_TO_ADDR
// ChangeMissionObjectives ( M2b ) ;
2481: LD_STRING M2b
2483: PPUSH
2484: CALL_OW 337
// end ;
2488: END
// every 0 0$1 trigger MissionStart do
2489: LD_EXP 1
2493: IFFALSE 2534
2495: GO 2497
2497: DISABLE
// begin wait ( BradfordTerminatesMissionTimer ) ;
2498: LD_EXP 39
2502: PPUSH
2503: CALL_OW 67
// DialogueOn ;
2507: CALL_OW 6
// SayRadio ( Bradford , D5-Bradford-3 ) ;
2511: LD_EXP 11
2515: PPUSH
2516: LD_STRING D5-Bradford-3
2518: PPUSH
2519: CALL_OW 94
// DialogueOff ;
2523: CALL_OW 7
// YouLost ( LostCommand ) ;
2527: LD_STRING LostCommand
2529: PPUSH
2530: CALL_OW 104
// end ;
2534: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 8 do
2535: LD_INT 22
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: PUSH
2545: LD_INT 21
2547: PUSH
2548: LD_INT 1
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: PUSH
2564: LD_INT 8
2566: LESS
2567: IFFALSE 2579
2569: GO 2571
2571: DISABLE
// YouLost ( SimoneSquad ) ;
2572: LD_STRING SimoneSquad
2574: PPUSH
2575: CALL_OW 104
2579: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) < 8 and not ReachedBase do
2580: LD_INT 22
2582: PUSH
2583: LD_INT 4
2585: PUSH
2586: EMPTY
2587: LIST
2588: LIST
2589: PUSH
2590: LD_INT 21
2592: PUSH
2593: LD_INT 1
2595: PUSH
2596: EMPTY
2597: LIST
2598: LIST
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: PPUSH
2604: CALL_OW 69
2608: PUSH
2609: LD_INT 8
2611: LESS
2612: PUSH
2613: LD_EXP 3
2617: NOT
2618: AND
2619: IFFALSE 2631
2621: GO 2623
2623: DISABLE
// YouLost ( KathrynSquad ) ;
2624: LD_STRING KathrynSquad
2626: PPUSH
2627: CALL_OW 104
2631: END
// every 0 0$1 trigger See ( 7 , bater1 ) do var nul ;
2632: LD_INT 7
2634: PPUSH
2635: LD_INT 225
2637: PPUSH
2638: CALL_OW 292
2642: IFFALSE 2690
2644: GO 2646
2646: DISABLE
2647: LD_INT 0
2649: PPUSH
// begin DialogueOn ;
2650: CALL_OW 6
// CenterOnUnits ( bater1 ) ;
2654: LD_INT 225
2656: PPUSH
2657: CALL_OW 85
// Say ( Miller , D5a-Miller-1 ) ;
2661: LD_EXP 8
2665: PPUSH
2666: LD_STRING D5a-Miller-1
2668: PPUSH
2669: CALL_OW 88
// nul = Query ( QVehicles ) ;
2673: LD_ADDR_VAR 0 1
2677: PUSH
2678: LD_STRING QVehicles
2680: PPUSH
2681: CALL_OW 97
2685: ST_TO_ADDR
// DialogueOff ;
2686: CALL_OW 7
// end ;
2690: PPOPN 1
2692: END
// every 0 0$1 trigger GetLives ( bater1 ) = 1000 do
2693: LD_INT 225
2695: PPUSH
2696: CALL_OW 256
2700: PUSH
2701: LD_INT 1000
2703: EQUAL
2704: IFFALSE 2719
2706: GO 2708
2708: DISABLE
// SetSide ( bater1 , 7 ) ;
2709: LD_INT 225
2711: PPUSH
2712: LD_INT 7
2714: PPUSH
2715: CALL_OW 235
2719: END
// every 0 0$1 trigger GetLives ( bater2 ) = 1000 do
2720: LD_INT 226
2722: PPUSH
2723: CALL_OW 256
2727: PUSH
2728: LD_INT 1000
2730: EQUAL
2731: IFFALSE 2746
2733: GO 2735
2735: DISABLE
// SetSide ( bater2 , 7 ) ;
2736: LD_INT 226
2738: PPUSH
2739: LD_INT 7
2741: PPUSH
2742: CALL_OW 235
2746: END
// every 0 0$1 trigger GetLives ( bater3 ) = 1000 do
2747: LD_INT 227
2749: PPUSH
2750: CALL_OW 256
2754: PUSH
2755: LD_INT 1000
2757: EQUAL
2758: IFFALSE 2773
2760: GO 2762
2762: DISABLE
// SetSide ( bater3 , 7 ) ; end_of_file
2763: LD_INT 227
2765: PPUSH
2766: LD_INT 7
2768: PPUSH
2769: CALL_OW 235
2773: END
// export Simone , Kathryn , Miller , Pravar , AMSurvivors ; export Bradford , Bernie , Sidorovich , Micoyan , Dvalishvili , Heisenberg ; export AvengerSquad , AvengerReserve , AvengerMechs , AvengerNonMechs ; export KathrynSquad , KathrynMechs ; export function CreatePersonas ; var i , un ; begin
2774: LD_INT 0
2776: PPUSH
2777: PPUSH
2778: PPUSH
// uc_side := 7 ;
2779: LD_ADDR_OWVAR 20
2783: PUSH
2784: LD_INT 7
2786: ST_TO_ADDR
// if debug then
2787: LD_EXP 2
2791: IFFALSE 3027
// begin uc_nation := nation_american ;
2793: LD_ADDR_OWVAR 21
2797: PUSH
2798: LD_INT 1
2800: ST_TO_ADDR
// hc_sex = sex_female ;
2801: LD_ADDR_OWVAR 27
2805: PUSH
2806: LD_INT 2
2808: ST_TO_ADDR
// hc_importance = 100 ;
2809: LD_ADDR_OWVAR 32
2813: PUSH
2814: LD_INT 100
2816: ST_TO_ADDR
// hc_skills = [ 4 , 3 , 5 , 2 ] ;
2817: LD_ADDR_OWVAR 31
2821: PUSH
2822: LD_INT 4
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 5
2830: PUSH
2831: LD_INT 2
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: LIST
2839: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2840: LD_ADDR_OWVAR 29
2844: PUSH
2845: LD_INT 12
2847: PUSH
2848: LD_INT 10
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: ST_TO_ADDR
// hc_name := Simone Gray ;
2855: LD_ADDR_OWVAR 26
2859: PUSH
2860: LD_STRING Simone Gray
2862: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_Heroines ;
2863: LD_ADDR_OWVAR 33
2867: PUSH
2868: LD_STRING ZieloneLaserki_Heroines
2870: ST_TO_ADDR
// hc_face_number := 1 ;
2871: LD_ADDR_OWVAR 34
2875: PUSH
2876: LD_INT 1
2878: ST_TO_ADDR
// Simone := CreateHuman ;
2879: LD_ADDR_EXP 6
2883: PUSH
2884: CALL_OW 44
2888: ST_TO_ADDR
// InitHc ;
2889: CALL_OW 19
// hc_importance := 0 ;
2893: LD_ADDR_OWVAR 32
2897: PUSH
2898: LD_INT 0
2900: ST_TO_ADDR
// hc_gallery :=  ;
2901: LD_ADDR_OWVAR 33
2905: PUSH
2906: LD_STRING 
2908: ST_TO_ADDR
// hc_name :=  ;
2909: LD_ADDR_OWVAR 26
2913: PUSH
2914: LD_STRING 
2916: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
2917: LD_INT 1
2919: PPUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 10
2925: PPUSH
2926: CALL_OW 380
// Miller := CreateHuman ;
2930: LD_ADDR_EXP 8
2934: PUSH
2935: CALL_OW 44
2939: ST_TO_ADDR
// Pravar := CreateHuman ;
2940: LD_ADDR_EXP 9
2944: PUSH
2945: CALL_OW 44
2949: ST_TO_ADDR
// AMSurvivors := [ ] ;
2950: LD_ADDR_EXP 10
2954: PUSH
2955: EMPTY
2956: ST_TO_ADDR
// for i = 1 to 6 do
2957: LD_ADDR_VAR 0 2
2961: PUSH
2962: DOUBLE
2963: LD_INT 1
2965: DEC
2966: ST_TO_ADDR
2967: LD_INT 6
2969: PUSH
2970: FOR_TO
2971: IFFALSE 3023
// begin InitHc ;
2973: CALL_OW 19
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
2977: LD_INT 0
2979: PPUSH
2980: LD_INT 1
2982: PPUSH
2983: LD_INT 4
2985: PPUSH
2986: CALL_OW 12
2990: PPUSH
2991: LD_INT 10
2993: PPUSH
2994: CALL_OW 380
// AMSurvivors := Insert ( AmSurvivors , 1 , CreateHuman ) ;
2998: LD_ADDR_EXP 10
3002: PUSH
3003: LD_EXP 10
3007: PPUSH
3008: LD_INT 1
3010: PPUSH
3011: CALL_OW 44
3015: PPUSH
3016: CALL_OW 2
3020: ST_TO_ADDR
// end ;
3021: GO 2970
3023: POP
3024: POP
// end else
3025: GO 3079
// begin Simone = CreateCharacter ( Simone ) ;
3027: LD_ADDR_EXP 6
3031: PUSH
3032: LD_STRING Simone
3034: PPUSH
3035: CALL_OW 34
3039: ST_TO_ADDR
// Miller = CreateCharacter ( Miller ) ;
3040: LD_ADDR_EXP 8
3044: PUSH
3045: LD_STRING Miller
3047: PPUSH
3048: CALL_OW 34
3052: ST_TO_ADDR
// Pravar = CreateCharacter ( Pravar ) ;
3053: LD_ADDR_EXP 9
3057: PUSH
3058: LD_STRING Pravar
3060: PPUSH
3061: CALL_OW 34
3065: ST_TO_ADDR
// AMSurvivors = CreateCharacterSet ( AM03_Survivors ) ;
3066: LD_ADDR_EXP 10
3070: PUSH
3071: LD_STRING AM03_Survivors
3073: PPUSH
3074: CALL_OW 31
3078: ST_TO_ADDR
// end ; AvengerSquad := Simone ^ Miller ^ Pravar ^ AMSurvivors ;
3079: LD_ADDR_EXP 17
3083: PUSH
3084: LD_EXP 6
3088: PUSH
3089: LD_EXP 8
3093: ADD
3094: PUSH
3095: LD_EXP 9
3099: ADD
3100: PUSH
3101: LD_EXP 10
3105: ADD
3106: ST_TO_ADDR
// for i in AvengerSquad do
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_EXP 17
3116: PUSH
3117: FOR_IN
3118: IFFALSE 3209
// begin if GetSkill ( i , skill_scientistic ) > 5 then
3120: LD_VAR 0 2
3124: PPUSH
3125: LD_INT 4
3127: PPUSH
3128: CALL_OW 259
3132: PUSH
3133: LD_INT 5
3135: GREATER
3136: IFFALSE 3150
// SetClass ( i , class_scientistic ) ;
3138: LD_VAR 0 2
3142: PPUSH
3143: LD_INT 4
3145: PPUSH
3146: CALL_OW 336
// if GetSkill ( i , skill_mechanical ) > 5 then
3150: LD_VAR 0 2
3154: PPUSH
3155: LD_INT 3
3157: PPUSH
3158: CALL_OW 259
3162: PUSH
3163: LD_INT 5
3165: GREATER
3166: IFFALSE 3180
// SetClass ( i , class_mechanic ) ;
3168: LD_VAR 0 2
3172: PPUSH
3173: LD_INT 3
3175: PPUSH
3176: CALL_OW 336
// if GetClass ( i ) = class_engineer then
3180: LD_VAR 0 2
3184: PPUSH
3185: CALL_OW 257
3189: PUSH
3190: LD_INT 2
3192: EQUAL
3193: IFFALSE 3207
// SetClass ( i , class_soldier ) ;
3195: LD_VAR 0 2
3199: PPUSH
3200: LD_INT 1
3202: PPUSH
3203: CALL_OW 336
// end ;
3207: GO 3117
3209: POP
3210: POP
// SetClass ( Simone , class_mechanic ) ;
3211: LD_EXP 6
3215: PPUSH
3216: LD_INT 3
3218: PPUSH
3219: CALL_OW 336
// SetClass ( Miller , class_soldier ) ;
3223: LD_EXP 8
3227: PPUSH
3228: LD_INT 1
3230: PPUSH
3231: CALL_OW 336
// PrepareScientist ( 1 , 10 ) ;
3235: LD_INT 1
3237: PPUSH
3238: LD_INT 10
3240: PPUSH
3241: CALL_OW 384
// AvengerSquad := AvengerSquad ^ CreateHuman ;
3245: LD_ADDR_EXP 17
3249: PUSH
3250: LD_EXP 17
3254: PUSH
3255: CALL_OW 44
3259: ADD
3260: ST_TO_ADDR
// uc_nation := nation_american ;
3261: LD_ADDR_OWVAR 21
3265: PUSH
3266: LD_INT 1
3268: ST_TO_ADDR
// hc_importance = Rand ( 10 , 50 ) ;
3269: LD_ADDR_OWVAR 32
3273: PUSH
3274: LD_INT 10
3276: PPUSH
3277: LD_INT 50
3279: PPUSH
3280: CALL_OW 12
3284: ST_TO_ADDR
// PrepareSoldier ( 1 , 9 ) ;
3285: LD_INT 1
3287: PPUSH
3288: LD_INT 9
3290: PPUSH
3291: CALL_OW 381
// hc_name := Bernie Hernandez ;
3295: LD_ADDR_OWVAR 26
3299: PUSH
3300: LD_STRING Bernie Hernandez
3302: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_AddtFaces ;
3303: LD_ADDR_OWVAR 33
3307: PUSH
3308: LD_STRING ZieloneLaserki_AddtFaces
3310: ST_TO_ADDR
// hc_face_number := 5 ;
3311: LD_ADDR_OWVAR 34
3315: PUSH
3316: LD_INT 5
3318: ST_TO_ADDR
// Bernie := CreateHuman ;
3319: LD_ADDR_EXP 12
3323: PUSH
3324: CALL_OW 44
3328: ST_TO_ADDR
// AvengerSquad := AvengerSquad ^ Bernie ;
3329: LD_ADDR_EXP 17
3333: PUSH
3334: LD_EXP 17
3338: PUSH
3339: LD_EXP 12
3343: ADD
3344: ST_TO_ADDR
// hc_name :=  ;
3345: LD_ADDR_OWVAR 26
3349: PUSH
3350: LD_STRING 
3352: ST_TO_ADDR
// hc_gallery :=  ;
3353: LD_ADDR_OWVAR 33
3357: PUSH
3358: LD_STRING 
3360: ST_TO_ADDR
// AvengerReserve := 16 - AvengerSquad ;
3361: LD_ADDR_EXP 18
3365: PUSH
3366: LD_INT 16
3368: PUSH
3369: LD_EXP 17
3373: MINUS
3374: ST_TO_ADDR
// for i = 1 to AvengerReserve do
3375: LD_ADDR_VAR 0 2
3379: PUSH
3380: DOUBLE
3381: LD_INT 1
3383: DEC
3384: ST_TO_ADDR
3385: LD_EXP 18
3389: PUSH
3390: FOR_TO
3391: IFFALSE 3536
// begin case Rand ( 1 , 10 ) of 1 .. 5 :
3393: LD_INT 1
3395: PPUSH
3396: LD_INT 10
3398: PPUSH
3399: CALL_OW 12
3403: PUSH
3404: LD_INT 1
3406: DOUBLE
3407: GREATEREQUAL
3408: IFFALSE 3416
3410: LD_INT 5
3412: DOUBLE
3413: LESSEQUAL
3414: IFTRUE 3418
3416: GO 3447
3418: POP
// begin PrepareSoldier ( 1 , 8 ) ;
3419: LD_INT 1
3421: PPUSH
3422: LD_INT 8
3424: PPUSH
3425: CALL_OW 381
// AvengerSquad := AvengerSquad ^ CreateHuman ;
3429: LD_ADDR_EXP 17
3433: PUSH
3434: LD_EXP 17
3438: PUSH
3439: CALL_OW 44
3443: ADD
3444: ST_TO_ADDR
// end ; 6 .. 8 :
3445: GO 3534
3447: LD_INT 6
3449: DOUBLE
3450: GREATEREQUAL
3451: IFFALSE 3459
3453: LD_INT 8
3455: DOUBLE
3456: LESSEQUAL
3457: IFTRUE 3461
3459: GO 3490
3461: POP
// begin PrepareMechanic ( 1 , 8 ) ;
3462: LD_INT 1
3464: PPUSH
3465: LD_INT 8
3467: PPUSH
3468: CALL_OW 383
// AvengerSquad := AvengerSquad ^ CreateHuman ;
3472: LD_ADDR_EXP 17
3476: PUSH
3477: LD_EXP 17
3481: PUSH
3482: CALL_OW 44
3486: ADD
3487: ST_TO_ADDR
// end ; 9 .. 10 :
3488: GO 3534
3490: LD_INT 9
3492: DOUBLE
3493: GREATEREQUAL
3494: IFFALSE 3502
3496: LD_INT 10
3498: DOUBLE
3499: LESSEQUAL
3500: IFTRUE 3504
3502: GO 3533
3504: POP
// begin PrepareScientist ( 1 , 8 ) ;
3505: LD_INT 1
3507: PPUSH
3508: LD_INT 8
3510: PPUSH
3511: CALL_OW 384
// AvengerSquad := AvengerSquad ^ CreateHuman ;
3515: LD_ADDR_EXP 17
3519: PUSH
3520: LD_EXP 17
3524: PUSH
3525: CALL_OW 44
3529: ADD
3530: ST_TO_ADDR
// end ; end ;
3531: GO 3534
3533: POP
// end ;
3534: GO 3390
3536: POP
3537: POP
// for i in AvengerSquad do
3538: LD_ADDR_VAR 0 2
3542: PUSH
3543: LD_EXP 17
3547: PUSH
3548: FOR_IN
3549: IFFALSE 3602
// begin if GetClass ( i ) = class_mechanic then
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 257
3560: PUSH
3561: LD_INT 3
3563: EQUAL
3564: IFFALSE 3584
// AvengerMechs := AvengerMechs ^ i else
3566: LD_ADDR_EXP 19
3570: PUSH
3571: LD_EXP 19
3575: PUSH
3576: LD_VAR 0 2
3580: ADD
3581: ST_TO_ADDR
3582: GO 3600
// AvengerNonMechs := AvengerNonMechs ^ i ;
3584: LD_ADDR_EXP 20
3588: PUSH
3589: LD_EXP 20
3593: PUSH
3594: LD_VAR 0 2
3598: ADD
3599: ST_TO_ADDR
// end ;
3600: GO 3548
3602: POP
3603: POP
// uc_side := 4 ;
3604: LD_ADDR_OWVAR 20
3608: PUSH
3609: LD_INT 4
3611: ST_TO_ADDR
// if debug then
3612: LD_EXP 2
3616: IFFALSE 3728
// begin uc_nation := nation_american ;
3618: LD_ADDR_OWVAR 21
3622: PUSH
3623: LD_INT 1
3625: ST_TO_ADDR
// hc_importance = 110 ;
3626: LD_ADDR_OWVAR 32
3630: PUSH
3631: LD_INT 110
3633: ST_TO_ADDR
// hc_sex = sex_female ;
3634: LD_ADDR_OWVAR 27
3638: PUSH
3639: LD_INT 2
3641: ST_TO_ADDR
// hc_skills = [ 2 , 2 , 4 , 3 ] ;
3642: LD_ADDR_OWVAR 31
3646: PUSH
3647: LD_INT 2
3649: PUSH
3650: LD_INT 2
3652: PUSH
3653: LD_INT 4
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: LIST
3663: LIST
3664: ST_TO_ADDR
// hc_attr = [ 11 , 10 ] ;
3665: LD_ADDR_OWVAR 29
3669: PUSH
3670: LD_INT 11
3672: PUSH
3673: LD_INT 10
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: ST_TO_ADDR
// hc_name := Kathryn Gray ;
3680: LD_ADDR_OWVAR 26
3684: PUSH
3685: LD_STRING Kathryn Gray
3687: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_Heroines ;
3688: LD_ADDR_OWVAR 33
3692: PUSH
3693: LD_STRING ZieloneLaserki_Heroines
3695: ST_TO_ADDR
// hc_face_number := 2 ;
3696: LD_ADDR_OWVAR 34
3700: PUSH
3701: LD_INT 2
3703: ST_TO_ADDR
// Kathryn := CreateHuman ;
3704: LD_ADDR_EXP 7
3708: PUSH
3709: CALL_OW 44
3713: ST_TO_ADDR
// hc_importance := 0 ;
3714: LD_ADDR_OWVAR 32
3718: PUSH
3719: LD_INT 0
3721: ST_TO_ADDR
// InitHc ;
3722: CALL_OW 19
// end else
3726: GO 3741
// Kathryn = CreateCharacter ( Kathryn ) ;
3728: LD_ADDR_EXP 7
3732: PUSH
3733: LD_STRING Kathryn
3735: PPUSH
3736: CALL_OW 34
3740: ST_TO_ADDR
// SetClass ( Kathryn , class_mechanic ) ;
3741: LD_EXP 7
3745: PPUSH
3746: LD_INT 3
3748: PPUSH
3749: CALL_OW 336
// KathrynSquad := Kathryn ;
3753: LD_ADDR_EXP 21
3757: PUSH
3758: LD_EXP 7
3762: ST_TO_ADDR
// KathrynMechs := Kathryn ;
3763: LD_ADDR_EXP 22
3767: PUSH
3768: LD_EXP 7
3772: ST_TO_ADDR
// for i = 1 to 8 do
3773: LD_ADDR_VAR 0 2
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 8
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3817
// begin PrepareSoldier ( 1 , 7 ) ;
3789: LD_INT 1
3791: PPUSH
3792: LD_INT 7
3794: PPUSH
3795: CALL_OW 381
// KathrynSquad := KathrynSquad ^ CreateHuman ;
3799: LD_ADDR_EXP 21
3803: PUSH
3804: LD_EXP 21
3808: PUSH
3809: CALL_OW 44
3813: ADD
3814: ST_TO_ADDR
// end ;
3815: GO 3786
3817: POP
3818: POP
// for i = 1 to 11 do
3819: LD_ADDR_VAR 0 2
3823: PUSH
3824: DOUBLE
3825: LD_INT 1
3827: DEC
3828: ST_TO_ADDR
3829: LD_INT 11
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3863
// begin PrepareMechanic ( 1 , 7 ) ;
3835: LD_INT 1
3837: PPUSH
3838: LD_INT 7
3840: PPUSH
3841: CALL_OW 383
// KathrynMechs := KathrynMechs ^ CreateHuman ;
3845: LD_ADDR_EXP 22
3849: PUSH
3850: LD_EXP 22
3854: PUSH
3855: CALL_OW 44
3859: ADD
3860: ST_TO_ADDR
// end ;
3861: GO 3832
3863: POP
3864: POP
// for i = 1 to 4 do
3865: LD_ADDR_VAR 0 2
3869: PUSH
3870: DOUBLE
3871: LD_INT 1
3873: DEC
3874: ST_TO_ADDR
3875: LD_INT 4
3877: PUSH
3878: FOR_TO
3879: IFFALSE 3909
// begin PrepareScientist ( 1 , 7 ) ;
3881: LD_INT 1
3883: PPUSH
3884: LD_INT 7
3886: PPUSH
3887: CALL_OW 384
// KathrynSquad := KathrynSquad ^ CreateHuman ;
3891: LD_ADDR_EXP 21
3895: PUSH
3896: LD_EXP 21
3900: PUSH
3901: CALL_OW 44
3905: ADD
3906: ST_TO_ADDR
// end ;
3907: GO 3878
3909: POP
3910: POP
// uc_side := 8 ;
3911: LD_ADDR_OWVAR 20
3915: PUSH
3916: LD_INT 8
3918: ST_TO_ADDR
// hc_class = class_soldier ;
3919: LD_ADDR_OWVAR 28
3923: PUSH
3924: LD_INT 1
3926: ST_TO_ADDR
// uc_nation := nation_arabian ;
3927: LD_ADDR_OWVAR 21
3931: PUSH
3932: LD_INT 2
3934: ST_TO_ADDR
// hc_sex = sex_male ;
3935: LD_ADDR_OWVAR 27
3939: PUSH
3940: LD_INT 1
3942: ST_TO_ADDR
// hc_importance = 40 ;
3943: LD_ADDR_OWVAR 32
3947: PUSH
3948: LD_INT 40
3950: ST_TO_ADDR
// hc_skills = [ 9 , 4 , 8 , 3 ] ;
3951: LD_ADDR_OWVAR 31
3955: PUSH
3956: LD_INT 9
3958: PUSH
3959: LD_INT 4
3961: PUSH
3962: LD_INT 8
3964: PUSH
3965: LD_INT 3
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: LIST
3973: ST_TO_ADDR
// hc_attr = [ 15 , 10 ] ;
3974: LD_ADDR_OWVAR 29
3978: PUSH
3979: LD_INT 15
3981: PUSH
3982: LD_INT 10
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: ST_TO_ADDR
// hc_name := Giorgi Dvalishvili ;
3989: LD_ADDR_OWVAR 26
3993: PUSH
3994: LD_STRING Giorgi Dvalishvili
3996: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_Dvalishvili ;
3997: LD_ADDR_OWVAR 33
4001: PUSH
4002: LD_STRING ZieloneLaserki_Dvalishvili
4004: ST_TO_ADDR
// hc_face_number := 1 ;
4005: LD_ADDR_OWVAR 34
4009: PUSH
4010: LD_INT 1
4012: ST_TO_ADDR
// Dvalishvili := CreateHuman ;
4013: LD_ADDR_EXP 15
4017: PUSH
4018: CALL_OW 44
4022: ST_TO_ADDR
// uc_side := 1 ;
4023: LD_ADDR_OWVAR 20
4027: PUSH
4028: LD_INT 1
4030: ST_TO_ADDR
// hc_class = class_soldier ;
4031: LD_ADDR_OWVAR 28
4035: PUSH
4036: LD_INT 1
4038: ST_TO_ADDR
// uc_nation := nation_american ;
4039: LD_ADDR_OWVAR 21
4043: PUSH
4044: LD_INT 1
4046: ST_TO_ADDR
// hc_importance = 70 ;
4047: LD_ADDR_OWVAR 32
4051: PUSH
4052: LD_INT 70
4054: ST_TO_ADDR
// PrepareSoldier ( 1 , 8 ) ;
4055: LD_INT 1
4057: PPUSH
4058: LD_INT 8
4060: PPUSH
4061: CALL_OW 381
// hc_attr = [ 10 , 10 ] ;
4065: LD_ADDR_OWVAR 29
4069: PUSH
4070: LD_INT 10
4072: PUSH
4073: LD_INT 10
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: ST_TO_ADDR
// hc_name := Bradford ;
4080: LD_ADDR_OWVAR 26
4084: PUSH
4085: LD_STRING Bradford
4087: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_AddtFaces2 ;
4088: LD_ADDR_OWVAR 33
4092: PUSH
4093: LD_STRING ZieloneLaserki_AddtFaces2
4095: ST_TO_ADDR
// hc_face_number := 3 ;
4096: LD_ADDR_OWVAR 34
4100: PUSH
4101: LD_INT 3
4103: ST_TO_ADDR
// Bradford := CreateHuman ;
4104: LD_ADDR_EXP 11
4108: PUSH
4109: CALL_OW 44
4113: ST_TO_ADDR
// uc_side := 4 ;
4114: LD_ADDR_OWVAR 20
4118: PUSH
4119: LD_INT 4
4121: ST_TO_ADDR
// hc_class = class_soldier ;
4122: LD_ADDR_OWVAR 28
4126: PUSH
4127: LD_INT 1
4129: ST_TO_ADDR
// uc_nation := nation_american ;
4130: LD_ADDR_OWVAR 21
4134: PUSH
4135: LD_INT 1
4137: ST_TO_ADDR
// hc_importance = 70 ;
4138: LD_ADDR_OWVAR 32
4142: PUSH
4143: LD_INT 70
4145: ST_TO_ADDR
// PrepareSoldier ( 1 , 8 ) ;
4146: LD_INT 1
4148: PPUSH
4149: LD_INT 8
4151: PPUSH
4152: CALL_OW 381
// hc_attr = [ 10 , 10 ] ;
4156: LD_ADDR_OWVAR 29
4160: PUSH
4161: LD_INT 10
4163: PUSH
4164: LD_INT 10
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: ST_TO_ADDR
// hc_name :=  ;
4171: LD_ADDR_OWVAR 26
4175: PUSH
4176: LD_STRING 
4178: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_AddtFaces ;
4179: LD_ADDR_OWVAR 33
4183: PUSH
4184: LD_STRING ZieloneLaserki_AddtFaces
4186: ST_TO_ADDR
// hc_face_number := 6 ;
4187: LD_ADDR_OWVAR 34
4191: PUSH
4192: LD_INT 6
4194: ST_TO_ADDR
// Heisenberg := CreateHuman ;
4195: LD_ADDR_EXP 16
4199: PUSH
4200: CALL_OW 44
4204: ST_TO_ADDR
// uc_side := 3 ;
4205: LD_ADDR_OWVAR 20
4209: PUSH
4210: LD_INT 3
4212: ST_TO_ADDR
// hc_class = class_soldier ;
4213: LD_ADDR_OWVAR 28
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// uc_nation := nation_russian ;
4221: LD_ADDR_OWVAR 21
4225: PUSH
4226: LD_INT 3
4228: ST_TO_ADDR
// hc_importance = 70 ;
4229: LD_ADDR_OWVAR 32
4233: PUSH
4234: LD_INT 70
4236: ST_TO_ADDR
// PrepareSoldier ( 1 , 8 ) ;
4237: LD_INT 1
4239: PPUSH
4240: LD_INT 8
4242: PPUSH
4243: CALL_OW 381
// hc_attr = [ 10 , 10 ] ;
4247: LD_ADDR_OWVAR 29
4251: PUSH
4252: LD_INT 10
4254: PUSH
4255: LD_INT 10
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: ST_TO_ADDR
// hc_name := Micoyan ;
4262: LD_ADDR_OWVAR 26
4266: PUSH
4267: LD_STRING Micoyan
4269: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_RusCommanders ;
4270: LD_ADDR_OWVAR 33
4274: PUSH
4275: LD_STRING ZieloneLaserki_RusCommanders
4277: ST_TO_ADDR
// hc_face_number := 4 ;
4278: LD_ADDR_OWVAR 34
4282: PUSH
4283: LD_INT 4
4285: ST_TO_ADDR
// Micoyan := CreateHuman ;
4286: LD_ADDR_EXP 14
4290: PUSH
4291: CALL_OW 44
4295: ST_TO_ADDR
// hc_class = class_soldier ;
4296: LD_ADDR_OWVAR 28
4300: PUSH
4301: LD_INT 1
4303: ST_TO_ADDR
// uc_nation := nation_russian ;
4304: LD_ADDR_OWVAR 21
4308: PUSH
4309: LD_INT 3
4311: ST_TO_ADDR
// hc_importance = 70 ;
4312: LD_ADDR_OWVAR 32
4316: PUSH
4317: LD_INT 70
4319: ST_TO_ADDR
// PrepareSoldier ( 1 , 8 ) ;
4320: LD_INT 1
4322: PPUSH
4323: LD_INT 8
4325: PPUSH
4326: CALL_OW 381
// hc_attr = [ 10 , 10 ] ;
4330: LD_ADDR_OWVAR 29
4334: PUSH
4335: LD_INT 10
4337: PUSH
4338: LD_INT 10
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: ST_TO_ADDR
// hc_name := Sidorovich ;
4345: LD_ADDR_OWVAR 26
4349: PUSH
4350: LD_STRING Sidorovich
4352: ST_TO_ADDR
// hc_gallery := ZieloneLaserki_Heroes ;
4353: LD_ADDR_OWVAR 33
4357: PUSH
4358: LD_STRING ZieloneLaserki_Heroes
4360: ST_TO_ADDR
// hc_face_number := 8 ;
4361: LD_ADDR_OWVAR 34
4365: PUSH
4366: LD_INT 8
4368: ST_TO_ADDR
// Sidorovich := CreateHuman ;
4369: LD_ADDR_EXP 13
4373: PUSH
4374: CALL_OW 44
4378: ST_TO_ADDR
// hc_name :=  ;
4379: LD_ADDR_OWVAR 26
4383: PUSH
4384: LD_STRING 
4386: ST_TO_ADDR
// hc_gallery :=  ;
4387: LD_ADDR_OWVAR 33
4391: PUSH
4392: LD_STRING 
4394: ST_TO_ADDR
// end ;
4395: LD_VAR 0 1
4399: RET
// export function Squad_Assembly ; var i , x , y , veh , filter ; begin
4400: LD_INT 0
4402: PPUSH
4403: PPUSH
4404: PPUSH
4405: PPUSH
4406: PPUSH
4407: PPUSH
// x := 1 ;
4408: LD_ADDR_VAR 0 3
4412: PUSH
4413: LD_INT 1
4415: ST_TO_ADDR
// y := 1 ;
4416: LD_ADDR_VAR 0 4
4420: PUSH
4421: LD_INT 1
4423: ST_TO_ADDR
// uc_side := 7 ;
4424: LD_ADDR_OWVAR 20
4428: PUSH
4429: LD_INT 7
4431: ST_TO_ADDR
// uc_nation := 1 ;
4432: LD_ADDR_OWVAR 21
4436: PUSH
4437: LD_INT 1
4439: ST_TO_ADDR
// for i = 1 to 4 do
4440: LD_ADDR_VAR 0 2
4444: PUSH
4445: DOUBLE
4446: LD_INT 1
4448: DEC
4449: ST_TO_ADDR
4450: LD_INT 4
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4597
// begin vc_chassis := us_morphling ;
4456: LD_ADDR_OWVAR 37
4460: PUSH
4461: LD_INT 5
4463: ST_TO_ADDR
// vc_engine := engine_siberite ;
4464: LD_ADDR_OWVAR 39
4468: PUSH
4469: LD_INT 3
4471: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
4472: LD_ADDR_OWVAR 40
4476: PUSH
4477: LD_INT 6
4479: ST_TO_ADDR
// vc_control := control_manual ;
4480: LD_ADDR_OWVAR 38
4484: PUSH
4485: LD_INT 1
4487: ST_TO_ADDR
// veh := CreateVehicle ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: CALL_OW 45
4497: ST_TO_ADDR
// if x <= AvengerMechs then
4498: LD_VAR 0 3
4502: PUSH
4503: LD_EXP 19
4507: LESSEQUAL
4508: IFFALSE 4546
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
4510: LD_EXP 19
4514: PUSH
4515: LD_VAR 0 3
4519: ARRAY
4520: PPUSH
4521: LD_VAR 0 5
4525: PPUSH
4526: CALL_OW 52
// x := x + 1 ;
4530: LD_ADDR_VAR 0 3
4534: PUSH
4535: LD_VAR 0 3
4539: PUSH
4540: LD_INT 1
4542: PLUS
4543: ST_TO_ADDR
// end else
4544: GO 4580
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
4546: LD_EXP 20
4550: PUSH
4551: LD_VAR 0 4
4555: ARRAY
4556: PPUSH
4557: LD_VAR 0 5
4561: PPUSH
4562: CALL_OW 52
// y := y + 1 ;
4566: LD_ADDR_VAR 0 4
4570: PUSH
4571: LD_VAR 0 4
4575: PUSH
4576: LD_INT 1
4578: PLUS
4579: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
4580: LD_VAR 0 5
4584: PPUSH
4585: LD_INT 1
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 49
// end ;
4595: GO 4453
4597: POP
4598: POP
// for i = 1 to 4 do
4599: LD_ADDR_VAR 0 2
4603: PUSH
4604: DOUBLE
4605: LD_INT 1
4607: DEC
4608: ST_TO_ADDR
4609: LD_INT 4
4611: PUSH
4612: FOR_TO
4613: IFFALSE 4756
// begin vc_chassis := us_morphling ;
4615: LD_ADDR_OWVAR 37
4619: PUSH
4620: LD_INT 5
4622: ST_TO_ADDR
// vc_engine := engine_siberite ;
4623: LD_ADDR_OWVAR 39
4627: PUSH
4628: LD_INT 3
4630: ST_TO_ADDR
// vc_weapon := us_double_laser ;
4631: LD_ADDR_OWVAR 40
4635: PUSH
4636: LD_INT 10
4638: ST_TO_ADDR
// vc_control := control_manual ;
4639: LD_ADDR_OWVAR 38
4643: PUSH
4644: LD_INT 1
4646: ST_TO_ADDR
// veh := CreateVehicle ;
4647: LD_ADDR_VAR 0 5
4651: PUSH
4652: CALL_OW 45
4656: ST_TO_ADDR
// if x <= AvengerMechs then
4657: LD_VAR 0 3
4661: PUSH
4662: LD_EXP 19
4666: LESSEQUAL
4667: IFFALSE 4705
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
4669: LD_EXP 19
4673: PUSH
4674: LD_VAR 0 3
4678: ARRAY
4679: PPUSH
4680: LD_VAR 0 5
4684: PPUSH
4685: CALL_OW 52
// x := x + 1 ;
4689: LD_ADDR_VAR 0 3
4693: PUSH
4694: LD_VAR 0 3
4698: PUSH
4699: LD_INT 1
4701: PLUS
4702: ST_TO_ADDR
// end else
4703: GO 4739
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
4705: LD_EXP 20
4709: PUSH
4710: LD_VAR 0 4
4714: ARRAY
4715: PPUSH
4716: LD_VAR 0 5
4720: PPUSH
4721: CALL_OW 52
// y := y + 1 ;
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: LD_VAR 0 4
4734: PUSH
4735: LD_INT 1
4737: PLUS
4738: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// end ;
4754: GO 4612
4756: POP
4757: POP
// if TeslaQuestCompleted then
4758: LD_EXP 25
4762: IFFALSE 4927
// for i = 1 to 4 do
4764: LD_ADDR_VAR 0 2
4768: PUSH
4769: DOUBLE
4770: LD_INT 1
4772: DEC
4773: ST_TO_ADDR
4774: LD_INT 4
4776: PUSH
4777: FOR_TO
4778: IFFALSE 4923
// begin vc_chassis := us_medium_tracked ;
4780: LD_ADDR_OWVAR 37
4784: PUSH
4785: LD_INT 3
4787: ST_TO_ADDR
// vc_engine := engine_siberite ;
4788: LD_ADDR_OWVAR 39
4792: PUSH
4793: LD_INT 3
4795: ST_TO_ADDR
// vc_weapon := us_tesla_coil ;
4796: LD_ADDR_OWVAR 40
4800: PUSH
4801: LD_EXP 27
4805: ST_TO_ADDR
// vc_control := control_manual ;
4806: LD_ADDR_OWVAR 38
4810: PUSH
4811: LD_INT 1
4813: ST_TO_ADDR
// veh := CreateVehicle ;
4814: LD_ADDR_VAR 0 5
4818: PUSH
4819: CALL_OW 45
4823: ST_TO_ADDR
// if x <= AvengerMechs then
4824: LD_VAR 0 3
4828: PUSH
4829: LD_EXP 19
4833: LESSEQUAL
4834: IFFALSE 4872
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
4836: LD_EXP 19
4840: PUSH
4841: LD_VAR 0 3
4845: ARRAY
4846: PPUSH
4847: LD_VAR 0 5
4851: PPUSH
4852: CALL_OW 52
// x := x + 1 ;
4856: LD_ADDR_VAR 0 3
4860: PUSH
4861: LD_VAR 0 3
4865: PUSH
4866: LD_INT 1
4868: PLUS
4869: ST_TO_ADDR
// end else
4870: GO 4906
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
4872: LD_EXP 20
4876: PUSH
4877: LD_VAR 0 4
4881: ARRAY
4882: PPUSH
4883: LD_VAR 0 5
4887: PPUSH
4888: CALL_OW 52
// y := y + 1 ;
4892: LD_ADDR_VAR 0 4
4896: PUSH
4897: LD_VAR 0 4
4901: PUSH
4902: LD_INT 1
4904: PLUS
4905: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
4906: LD_VAR 0 5
4910: PPUSH
4911: LD_INT 1
4913: PPUSH
4914: LD_INT 0
4916: PPUSH
4917: CALL_OW 49
// end else
4921: GO 4777
4923: POP
4924: POP
4925: GO 5086
// for i = 1 to 4 do
4927: LD_ADDR_VAR 0 2
4931: PUSH
4932: DOUBLE
4933: LD_INT 1
4935: DEC
4936: ST_TO_ADDR
4937: LD_INT 4
4939: PUSH
4940: FOR_TO
4941: IFFALSE 5084
// begin vc_chassis := us_medium_tracked ;
4943: LD_ADDR_OWVAR 37
4947: PUSH
4948: LD_INT 3
4950: ST_TO_ADDR
// vc_engine := engine_siberite ;
4951: LD_ADDR_OWVAR 39
4955: PUSH
4956: LD_INT 3
4958: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
4959: LD_ADDR_OWVAR 40
4963: PUSH
4964: LD_INT 4
4966: ST_TO_ADDR
// vc_control := control_manual ;
4967: LD_ADDR_OWVAR 38
4971: PUSH
4972: LD_INT 1
4974: ST_TO_ADDR
// veh := CreateVehicle ;
4975: LD_ADDR_VAR 0 5
4979: PUSH
4980: CALL_OW 45
4984: ST_TO_ADDR
// if x <= AvengerMechs then
4985: LD_VAR 0 3
4989: PUSH
4990: LD_EXP 19
4994: LESSEQUAL
4995: IFFALSE 5033
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
4997: LD_EXP 19
5001: PUSH
5002: LD_VAR 0 3
5006: ARRAY
5007: PPUSH
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 52
// x := x + 1 ;
5017: LD_ADDR_VAR 0 3
5021: PUSH
5022: LD_VAR 0 3
5026: PUSH
5027: LD_INT 1
5029: PLUS
5030: ST_TO_ADDR
// end else
5031: GO 5067
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
5033: LD_EXP 20
5037: PUSH
5038: LD_VAR 0 4
5042: ARRAY
5043: PPUSH
5044: LD_VAR 0 5
5048: PPUSH
5049: CALL_OW 52
// y := y + 1 ;
5053: LD_ADDR_VAR 0 4
5057: PUSH
5058: LD_VAR 0 4
5062: PUSH
5063: LD_INT 1
5065: PLUS
5066: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
5067: LD_VAR 0 5
5071: PPUSH
5072: LD_INT 1
5074: PPUSH
5075: LD_INT 0
5077: PPUSH
5078: CALL_OW 49
// end ;
5082: GO 4940
5084: POP
5085: POP
// for i = 1 to 3 do
5086: LD_ADDR_VAR 0 2
5090: PUSH
5091: DOUBLE
5092: LD_INT 1
5094: DEC
5095: ST_TO_ADDR
5096: LD_INT 3
5098: PUSH
5099: FOR_TO
5100: IFFALSE 5243
// begin vc_chassis := us_medium_tracked ;
5102: LD_ADDR_OWVAR 37
5106: PUSH
5107: LD_INT 3
5109: ST_TO_ADDR
// vc_engine := engine_siberite ;
5110: LD_ADDR_OWVAR 39
5114: PUSH
5115: LD_INT 3
5117: ST_TO_ADDR
// vc_weapon := us_rocket_launcher ;
5118: LD_ADDR_OWVAR 40
5122: PUSH
5123: LD_INT 7
5125: ST_TO_ADDR
// vc_control := control_manual ;
5126: LD_ADDR_OWVAR 38
5130: PUSH
5131: LD_INT 1
5133: ST_TO_ADDR
// veh := CreateVehicle ;
5134: LD_ADDR_VAR 0 5
5138: PUSH
5139: CALL_OW 45
5143: ST_TO_ADDR
// if x <= AvengerMechs then
5144: LD_VAR 0 3
5148: PUSH
5149: LD_EXP 19
5153: LESSEQUAL
5154: IFFALSE 5192
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
5156: LD_EXP 19
5160: PUSH
5161: LD_VAR 0 3
5165: ARRAY
5166: PPUSH
5167: LD_VAR 0 5
5171: PPUSH
5172: CALL_OW 52
// x := x + 1 ;
5176: LD_ADDR_VAR 0 3
5180: PUSH
5181: LD_VAR 0 3
5185: PUSH
5186: LD_INT 1
5188: PLUS
5189: ST_TO_ADDR
// end else
5190: GO 5226
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
5192: LD_EXP 20
5196: PUSH
5197: LD_VAR 0 4
5201: ARRAY
5202: PPUSH
5203: LD_VAR 0 5
5207: PPUSH
5208: CALL_OW 52
// y := y + 1 ;
5212: LD_ADDR_VAR 0 4
5216: PUSH
5217: LD_VAR 0 4
5221: PUSH
5222: LD_INT 1
5224: PLUS
5225: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
5226: LD_VAR 0 5
5230: PPUSH
5231: LD_INT 1
5233: PPUSH
5234: LD_INT 0
5236: PPUSH
5237: CALL_OW 49
// end ;
5241: GO 5099
5243: POP
5244: POP
// for i = 1 to 1 do
5245: LD_ADDR_VAR 0 2
5249: PUSH
5250: DOUBLE
5251: LD_INT 1
5253: DEC
5254: ST_TO_ADDR
5255: LD_INT 1
5257: PUSH
5258: FOR_TO
5259: IFFALSE 5402
// begin vc_chassis := us_medium_tracked ;
5261: LD_ADDR_OWVAR 37
5265: PUSH
5266: LD_INT 3
5268: ST_TO_ADDR
// vc_engine := engine_siberite ;
5269: LD_ADDR_OWVAR 39
5273: PUSH
5274: LD_INT 3
5276: ST_TO_ADDR
// vc_weapon := us_radar ;
5277: LD_ADDR_OWVAR 40
5281: PUSH
5282: LD_INT 11
5284: ST_TO_ADDR
// vc_control := control_manual ;
5285: LD_ADDR_OWVAR 38
5289: PUSH
5290: LD_INT 1
5292: ST_TO_ADDR
// veh := CreateVehicle ;
5293: LD_ADDR_VAR 0 5
5297: PUSH
5298: CALL_OW 45
5302: ST_TO_ADDR
// if x <= AvengerMechs then
5303: LD_VAR 0 3
5307: PUSH
5308: LD_EXP 19
5312: LESSEQUAL
5313: IFFALSE 5351
// begin PlaceHumanInUnit ( AvengerMechs [ x ] , veh ) ;
5315: LD_EXP 19
5319: PUSH
5320: LD_VAR 0 3
5324: ARRAY
5325: PPUSH
5326: LD_VAR 0 5
5330: PPUSH
5331: CALL_OW 52
// x := x + 1 ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: LD_VAR 0 3
5344: PUSH
5345: LD_INT 1
5347: PLUS
5348: ST_TO_ADDR
// end else
5349: GO 5385
// begin PlaceHumanInUnit ( AvengerNonMechs [ y ] , veh ) ;
5351: LD_EXP 20
5355: PUSH
5356: LD_VAR 0 4
5360: ARRAY
5361: PPUSH
5362: LD_VAR 0 5
5366: PPUSH
5367: CALL_OW 52
// y := y + 1 ;
5371: LD_ADDR_VAR 0 4
5375: PUSH
5376: LD_VAR 0 4
5380: PUSH
5381: LD_INT 1
5383: PLUS
5384: ST_TO_ADDR
// end ; PlaceUnitArea ( veh , StartArea , false ) ;
5385: LD_VAR 0 5
5389: PPUSH
5390: LD_INT 1
5392: PPUSH
5393: LD_INT 0
5395: PPUSH
5396: CALL_OW 49
// end ;
5400: GO 5258
5402: POP
5403: POP
// end ;
5404: LD_VAR 0 1
5408: RET
// export function Kathryn_Squad_Assembly ; var i , x , veh ; begin
5409: LD_INT 0
5411: PPUSH
5412: PPUSH
5413: PPUSH
5414: PPUSH
// x := 1 ;
5415: LD_ADDR_VAR 0 3
5419: PUSH
5420: LD_INT 1
5422: ST_TO_ADDR
// uc_side := 4 ;
5423: LD_ADDR_OWVAR 20
5427: PUSH
5428: LD_INT 4
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5540
// begin vc_chassis := us_heavy_tracked ;
5447: LD_ADDR_OWVAR 37
5451: PUSH
5452: LD_INT 4
5454: ST_TO_ADDR
// vc_engine := engine_siberite ;
5455: LD_ADDR_OWVAR 39
5459: PUSH
5460: LD_INT 3
5462: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
5463: LD_ADDR_OWVAR 40
5467: PUSH
5468: LD_INT 6
5470: ST_TO_ADDR
// vc_control := control_manual ;
5471: LD_ADDR_OWVAR 38
5475: PUSH
5476: LD_INT 1
5478: ST_TO_ADDR
// veh := CreateVehicle ;
5479: LD_ADDR_VAR 0 4
5483: PUSH
5484: CALL_OW 45
5488: ST_TO_ADDR
// PlaceHumanInUnit ( KathrynMechs [ x ] , veh ) ;
5489: LD_EXP 22
5493: PUSH
5494: LD_VAR 0 3
5498: ARRAY
5499: PPUSH
5500: LD_VAR 0 4
5504: PPUSH
5505: CALL_OW 52
// x := x + 1 ;
5509: LD_ADDR_VAR 0 3
5513: PUSH
5514: LD_VAR 0 3
5518: PUSH
5519: LD_INT 1
5521: PLUS
5522: ST_TO_ADDR
// PlaceUnitArea ( veh , StartAreaKathryn , false ) ;
5523: LD_VAR 0 4
5527: PPUSH
5528: LD_INT 2
5530: PPUSH
5531: LD_INT 0
5533: PPUSH
5534: CALL_OW 49
// end ;
5538: GO 5444
5540: POP
5541: POP
// if TeslaQuestCompleted then
5542: LD_EXP 25
5546: IFFALSE 5663
// for i = 1 to 4 do
5548: LD_ADDR_VAR 0 2
5552: PUSH
5553: DOUBLE
5554: LD_INT 1
5556: DEC
5557: ST_TO_ADDR
5558: LD_INT 4
5560: PUSH
5561: FOR_TO
5562: IFFALSE 5659
// begin vc_chassis := us_medium_tracked ;
5564: LD_ADDR_OWVAR 37
5568: PUSH
5569: LD_INT 3
5571: ST_TO_ADDR
// vc_engine := engine_siberite ;
5572: LD_ADDR_OWVAR 39
5576: PUSH
5577: LD_INT 3
5579: ST_TO_ADDR
// vc_weapon := us_tesla_coil ;
5580: LD_ADDR_OWVAR 40
5584: PUSH
5585: LD_EXP 27
5589: ST_TO_ADDR
// vc_control := control_manual ;
5590: LD_ADDR_OWVAR 38
5594: PUSH
5595: LD_INT 1
5597: ST_TO_ADDR
// veh := CreateVehicle ;
5598: LD_ADDR_VAR 0 4
5602: PUSH
5603: CALL_OW 45
5607: ST_TO_ADDR
// PlaceHumanInUnit ( KathrynMechs [ x ] , veh ) ;
5608: LD_EXP 22
5612: PUSH
5613: LD_VAR 0 3
5617: ARRAY
5618: PPUSH
5619: LD_VAR 0 4
5623: PPUSH
5624: CALL_OW 52
// x := x + 1 ;
5628: LD_ADDR_VAR 0 3
5632: PUSH
5633: LD_VAR 0 3
5637: PUSH
5638: LD_INT 1
5640: PLUS
5641: ST_TO_ADDR
// PlaceUnitArea ( veh , StartAreaKathryn , false ) ;
5642: LD_VAR 0 4
5646: PPUSH
5647: LD_INT 2
5649: PPUSH
5650: LD_INT 0
5652: PPUSH
5653: CALL_OW 49
// end else
5657: GO 5561
5659: POP
5660: POP
5661: GO 5774
// for i = 1 to 4 do
5663: LD_ADDR_VAR 0 2
5667: PUSH
5668: DOUBLE
5669: LD_INT 1
5671: DEC
5672: ST_TO_ADDR
5673: LD_INT 4
5675: PUSH
5676: FOR_TO
5677: IFFALSE 5772
// begin vc_chassis := us_medium_tracked ;
5679: LD_ADDR_OWVAR 37
5683: PUSH
5684: LD_INT 3
5686: ST_TO_ADDR
// vc_engine := engine_siberite ;
5687: LD_ADDR_OWVAR 39
5691: PUSH
5692: LD_INT 3
5694: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
5695: LD_ADDR_OWVAR 40
5699: PUSH
5700: LD_INT 4
5702: ST_TO_ADDR
// vc_control := control_manual ;
5703: LD_ADDR_OWVAR 38
5707: PUSH
5708: LD_INT 1
5710: ST_TO_ADDR
// veh := CreateVehicle ;
5711: LD_ADDR_VAR 0 4
5715: PUSH
5716: CALL_OW 45
5720: ST_TO_ADDR
// PlaceHumanInUnit ( KathrynMechs [ x ] , veh ) ;
5721: LD_EXP 22
5725: PUSH
5726: LD_VAR 0 3
5730: ARRAY
5731: PPUSH
5732: LD_VAR 0 4
5736: PPUSH
5737: CALL_OW 52
// x := x + 1 ;
5741: LD_ADDR_VAR 0 3
5745: PUSH
5746: LD_VAR 0 3
5750: PUSH
5751: LD_INT 1
5753: PLUS
5754: ST_TO_ADDR
// PlaceUnitArea ( veh , StartAreaKathryn , false ) ;
5755: LD_VAR 0 4
5759: PPUSH
5760: LD_INT 2
5762: PPUSH
5763: LD_INT 0
5765: PPUSH
5766: CALL_OW 49
// end ;
5770: GO 5676
5772: POP
5773: POP
// for i = 1 to 4 do
5774: LD_ADDR_VAR 0 2
5778: PUSH
5779: DOUBLE
5780: LD_INT 1
5782: DEC
5783: ST_TO_ADDR
5784: LD_INT 4
5786: PUSH
5787: FOR_TO
5788: IFFALSE 5883
// begin vc_chassis := us_medium_tracked ;
5790: LD_ADDR_OWVAR 37
5794: PUSH
5795: LD_INT 3
5797: ST_TO_ADDR
// vc_engine := engine_siberite ;
5798: LD_ADDR_OWVAR 39
5802: PUSH
5803: LD_INT 3
5805: ST_TO_ADDR
// vc_weapon := us_laser ;
5806: LD_ADDR_OWVAR 40
5810: PUSH
5811: LD_INT 9
5813: ST_TO_ADDR
// vc_control := control_manual ;
5814: LD_ADDR_OWVAR 38
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// veh := CreateVehicle ;
5822: LD_ADDR_VAR 0 4
5826: PUSH
5827: CALL_OW 45
5831: ST_TO_ADDR
// PlaceHumanInUnit ( KathrynMechs [ x ] , veh ) ;
5832: LD_EXP 22
5836: PUSH
5837: LD_VAR 0 3
5841: ARRAY
5842: PPUSH
5843: LD_VAR 0 4
5847: PPUSH
5848: CALL_OW 52
// x := x + 1 ;
5852: LD_ADDR_VAR 0 3
5856: PUSH
5857: LD_VAR 0 3
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: ST_TO_ADDR
// PlaceUnitArea ( veh , StartAreaKathryn , false ) ;
5866: LD_VAR 0 4
5870: PPUSH
5871: LD_INT 2
5873: PPUSH
5874: LD_INT 0
5876: PPUSH
5877: CALL_OW 49
// end ;
5881: GO 5787
5883: POP
5884: POP
// for i in KathrynSquad do
5885: LD_ADDR_VAR 0 2
5889: PUSH
5890: LD_EXP 21
5894: PUSH
5895: FOR_IN
5896: IFFALSE 5915
// PlaceUnitArea ( i , StartAreaKathryn , false ) ;
5898: LD_VAR 0 2
5902: PPUSH
5903: LD_INT 2
5905: PPUSH
5906: LD_INT 0
5908: PPUSH
5909: CALL_OW 49
5913: GO 5895
5915: POP
5916: POP
// KathrynSquad = KathrynSquad ^ KathrynMechs ;
5917: LD_ADDR_EXP 21
5921: PUSH
5922: LD_EXP 21
5926: PUSH
5927: LD_EXP 22
5931: ADD
5932: ST_TO_ADDR
// end ; end_of_file
5933: LD_VAR 0 1
5937: RET
// export ConvoysEscaped , EstherQuestCompleted , TeslaQuestCompleted ; export function LoadVariables ; begin
5938: LD_INT 0
5940: PPUSH
// ConvoysEscaped := LoadVariable ( AM03_Convoys , 0 ) ;
5941: LD_ADDR_EXP 23
5945: PUSH
5946: LD_STRING AM03_Convoys
5948: PPUSH
5949: LD_INT 0
5951: PPUSH
5952: CALL_OW 30
5956: ST_TO_ADDR
// EstherQuestCompleted := LoadVariable ( AM03_EstherResearch , 0 ) ;
5957: LD_ADDR_EXP 24
5961: PUSH
5962: LD_STRING AM03_EstherResearch
5964: PPUSH
5965: LD_INT 0
5967: PPUSH
5968: CALL_OW 30
5972: ST_TO_ADDR
// TeslaQuestCompleted := LoadVariable ( AM03_TeslaResearched , 0 ) ;
5973: LD_ADDR_EXP 25
5977: PUSH
5978: LD_STRING AM03_TeslaResearched
5980: PPUSH
5981: LD_INT 0
5983: PPUSH
5984: CALL_OW 30
5988: ST_TO_ADDR
// end ;
5989: LD_VAR 0 1
5993: RET
// export function Garrison_Buildings ( side ) ; var i , j , l , labs , factorio , depots , ilu_ludzi , ludz , filter ; begin
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
5999: PPUSH
6000: PPUSH
6001: PPUSH
6002: PPUSH
6003: PPUSH
6004: PPUSH
6005: PPUSH
// labs := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab ] ] ) ;
6006: LD_ADDR_VAR 0 6
6010: PUSH
6011: LD_INT 22
6013: PUSH
6014: LD_VAR 0 1
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 30
6025: PUSH
6026: LD_INT 6
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: PPUSH
6037: CALL_OW 69
6041: ST_TO_ADDR
// labs := labs ^ FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_half ] ] ) ;
6042: LD_ADDR_VAR 0 6
6046: PUSH
6047: LD_VAR 0 6
6051: PUSH
6052: LD_INT 22
6054: PUSH
6055: LD_VAR 0 1
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: PUSH
6064: LD_INT 30
6066: PUSH
6067: LD_INT 7
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PPUSH
6078: CALL_OW 69
6082: ADD
6083: ST_TO_ADDR
// labs := labs ^ FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
6084: LD_ADDR_VAR 0 6
6088: PUSH
6089: LD_VAR 0 6
6093: PUSH
6094: LD_INT 22
6096: PUSH
6097: LD_VAR 0 1
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 30
6108: PUSH
6109: LD_INT 8
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PPUSH
6120: CALL_OW 69
6124: ADD
6125: ST_TO_ADDR
// factorio := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) ;
6126: LD_ADDR_VAR 0 7
6130: PUSH
6131: LD_INT 22
6133: PUSH
6134: LD_VAR 0 1
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 30
6145: PUSH
6146: LD_INT 3
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 69
6161: ST_TO_ADDR
// depots := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_depot ] ] ) ;
6162: LD_ADDR_VAR 0 8
6166: PUSH
6167: LD_INT 22
6169: PUSH
6170: LD_VAR 0 1
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 30
6181: PUSH
6182: LD_INT 0
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PPUSH
6193: CALL_OW 69
6197: ST_TO_ADDR
// depots := depots ^ FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6198: LD_ADDR_VAR 0 8
6202: PUSH
6203: LD_VAR 0 8
6207: PUSH
6208: LD_INT 22
6210: PUSH
6211: LD_VAR 0 1
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 30
6222: PUSH
6223: LD_INT 1
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PPUSH
6234: CALL_OW 69
6238: ADD
6239: ST_TO_ADDR
// case side of 1 :
6240: LD_VAR 0 1
6244: PUSH
6245: LD_INT 1
6247: DOUBLE
6248: EQUAL
6249: IFTRUE 6253
6251: GO 6264
6253: POP
// uc_nation = nation_american ; 3 :
6254: LD_ADDR_OWVAR 21
6258: PUSH
6259: LD_INT 1
6261: ST_TO_ADDR
6262: GO 6303
6264: LD_INT 3
6266: DOUBLE
6267: EQUAL
6268: IFTRUE 6272
6270: GO 6283
6272: POP
// uc_nation = nation_russian ; 6 :
6273: LD_ADDR_OWVAR 21
6277: PUSH
6278: LD_INT 3
6280: ST_TO_ADDR
6281: GO 6303
6283: LD_INT 6
6285: DOUBLE
6286: EQUAL
6287: IFTRUE 6291
6289: GO 6302
6291: POP
// uc_nation = nation_russian ; end ;
6292: LD_ADDR_OWVAR 21
6296: PUSH
6297: LD_INT 3
6299: ST_TO_ADDR
6300: GO 6303
6302: POP
// for i = 1 to labs do
6303: LD_ADDR_VAR 0 3
6307: PUSH
6308: DOUBLE
6309: LD_INT 1
6311: DEC
6312: ST_TO_ADDR
6313: LD_VAR 0 6
6317: PUSH
6318: FOR_TO
6319: IFFALSE 6450
// begin if IsInUnit ( labs [ i ] ) = 0 then
6321: LD_VAR 0 6
6325: PUSH
6326: LD_VAR 0 3
6330: ARRAY
6331: PPUSH
6332: CALL_OW 310
6336: PUSH
6337: LD_INT 0
6339: EQUAL
6340: IFFALSE 6448
// begin uc_side = side ;
6342: LD_ADDR_OWVAR 20
6346: PUSH
6347: LD_VAR 0 1
6351: ST_TO_ADDR
// ilu_ludzi = Rand ( 2 , 4 ) ;
6352: LD_ADDR_VAR 0 9
6356: PUSH
6357: LD_INT 2
6359: PPUSH
6360: LD_INT 4
6362: PPUSH
6363: CALL_OW 12
6367: ST_TO_ADDR
// for j = 1 to ilu_ludzi do
6368: LD_ADDR_VAR 0 4
6372: PUSH
6373: DOUBLE
6374: LD_INT 1
6376: DEC
6377: ST_TO_ADDR
6378: LD_VAR 0 9
6382: PUSH
6383: FOR_TO
6384: IFFALSE 6446
// begin PrepareScientist ( 0 , RuSolMaxLevel ) ;
6386: LD_INT 0
6388: PPUSH
6389: LD_EXP 35
6393: PPUSH
6394: CALL_OW 384
// ludz = CreateHuman ;
6398: LD_ADDR_VAR 0 10
6402: PUSH
6403: CALL_OW 44
6407: ST_TO_ADDR
// PlaceHumanInUnit ( ludz , labs [ i ] ) ;
6408: LD_VAR 0 10
6412: PPUSH
6413: LD_VAR 0 6
6417: PUSH
6418: LD_VAR 0 3
6422: ARRAY
6423: PPUSH
6424: CALL_OW 52
// ilu_ludzi = Rand ( 2 , 4 ) ;
6428: LD_ADDR_VAR 0 9
6432: PUSH
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 4
6438: PPUSH
6439: CALL_OW 12
6443: ST_TO_ADDR
// end ;
6444: GO 6383
6446: POP
6447: POP
// end ; end ;
6448: GO 6318
6450: POP
6451: POP
// for i = 1 to factorio do
6452: LD_ADDR_VAR 0 3
6456: PUSH
6457: DOUBLE
6458: LD_INT 1
6460: DEC
6461: ST_TO_ADDR
6462: LD_VAR 0 7
6466: PUSH
6467: FOR_TO
6468: IFFALSE 6599
// begin if IsInUnit ( factorio [ i ] ) = 0 then
6470: LD_VAR 0 7
6474: PUSH
6475: LD_VAR 0 3
6479: ARRAY
6480: PPUSH
6481: CALL_OW 310
6485: PUSH
6486: LD_INT 0
6488: EQUAL
6489: IFFALSE 6597
// begin uc_side = side ;
6491: LD_ADDR_OWVAR 20
6495: PUSH
6496: LD_VAR 0 1
6500: ST_TO_ADDR
// ilu_ludzi = Rand ( 2 , 4 ) ;
6501: LD_ADDR_VAR 0 9
6505: PUSH
6506: LD_INT 2
6508: PPUSH
6509: LD_INT 4
6511: PPUSH
6512: CALL_OW 12
6516: ST_TO_ADDR
// for j = 1 to ilu_ludzi do
6517: LD_ADDR_VAR 0 4
6521: PUSH
6522: DOUBLE
6523: LD_INT 1
6525: DEC
6526: ST_TO_ADDR
6527: LD_VAR 0 9
6531: PUSH
6532: FOR_TO
6533: IFFALSE 6595
// begin PrepareMechanic ( 0 , RuSolMaxLevel ) ;
6535: LD_INT 0
6537: PPUSH
6538: LD_EXP 35
6542: PPUSH
6543: CALL_OW 383
// ludz = CreateHuman ;
6547: LD_ADDR_VAR 0 10
6551: PUSH
6552: CALL_OW 44
6556: ST_TO_ADDR
// PlaceHumanInUnit ( ludz , factorio [ i ] ) ;
6557: LD_VAR 0 10
6561: PPUSH
6562: LD_VAR 0 7
6566: PUSH
6567: LD_VAR 0 3
6571: ARRAY
6572: PPUSH
6573: CALL_OW 52
// ilu_ludzi = Rand ( 2 , 4 ) ;
6577: LD_ADDR_VAR 0 9
6581: PUSH
6582: LD_INT 2
6584: PPUSH
6585: LD_INT 4
6587: PPUSH
6588: CALL_OW 12
6592: ST_TO_ADDR
// end ;
6593: GO 6532
6595: POP
6596: POP
// end ; end ;
6597: GO 6467
6599: POP
6600: POP
// for i = 1 to depots do
6601: LD_ADDR_VAR 0 3
6605: PUSH
6606: DOUBLE
6607: LD_INT 1
6609: DEC
6610: ST_TO_ADDR
6611: LD_VAR 0 8
6615: PUSH
6616: FOR_TO
6617: IFFALSE 6732
// begin if IsInUnit ( depots [ i ] ) = 0 then
6619: LD_VAR 0 8
6623: PUSH
6624: LD_VAR 0 3
6628: ARRAY
6629: PPUSH
6630: CALL_OW 310
6634: PUSH
6635: LD_INT 0
6637: EQUAL
6638: IFFALSE 6730
// begin uc_side = side ;
6640: LD_ADDR_OWVAR 20
6644: PUSH
6645: LD_VAR 0 1
6649: ST_TO_ADDR
// ilu_ludzi = Rand ( 2 , 3 ) ;
6650: LD_ADDR_VAR 0 9
6654: PUSH
6655: LD_INT 2
6657: PPUSH
6658: LD_INT 3
6660: PPUSH
6661: CALL_OW 12
6665: ST_TO_ADDR
// for j = 1 to ilu_ludzi do
6666: LD_ADDR_VAR 0 4
6670: PUSH
6671: DOUBLE
6672: LD_INT 1
6674: DEC
6675: ST_TO_ADDR
6676: LD_VAR 0 9
6680: PUSH
6681: FOR_TO
6682: IFFALSE 6728
// begin PrepareEngineer ( 0 , RuSolMaxLevel ) ;
6684: LD_INT 0
6686: PPUSH
6687: LD_EXP 35
6691: PPUSH
6692: CALL_OW 382
// ludz = CreateHuman ;
6696: LD_ADDR_VAR 0 10
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// PlaceHumanInUnit ( ludz , depots [ i ] ) ;
6706: LD_VAR 0 10
6710: PPUSH
6711: LD_VAR 0 8
6715: PUSH
6716: LD_VAR 0 3
6720: ARRAY
6721: PPUSH
6722: CALL_OW 52
// end ;
6726: GO 6681
6728: POP
6729: POP
// end ; end ;
6730: GO 6616
6732: POP
6733: POP
// end ;
6734: LD_VAR 0 2
6738: RET
// export function Assemble_Barracks ( side ) ; var i , j , barrack , soldat , filter ; begin
6739: LD_INT 0
6741: PPUSH
6742: PPUSH
6743: PPUSH
6744: PPUSH
6745: PPUSH
6746: PPUSH
// case side of 1 :
6747: LD_VAR 0 1
6751: PUSH
6752: LD_INT 1
6754: DOUBLE
6755: EQUAL
6756: IFTRUE 6760
6758: GO 6771
6760: POP
// uc_nation = nation_american ; 3 :
6761: LD_ADDR_OWVAR 21
6765: PUSH
6766: LD_INT 1
6768: ST_TO_ADDR
6769: GO 6791
6771: LD_INT 3
6773: DOUBLE
6774: EQUAL
6775: IFTRUE 6779
6777: GO 6790
6779: POP
// uc_nation = nation_russian ; end ;
6780: LD_ADDR_OWVAR 21
6784: PUSH
6785: LD_INT 3
6787: ST_TO_ADDR
6788: GO 6791
6790: POP
// barrack := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
6791: LD_ADDR_VAR 0 5
6795: PUSH
6796: LD_INT 22
6798: PUSH
6799: LD_VAR 0 1
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_INT 5
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: PPUSH
6822: CALL_OW 69
6826: ST_TO_ADDR
// for i = 1 to barrack do
6827: LD_ADDR_VAR 0 3
6831: PUSH
6832: DOUBLE
6833: LD_INT 1
6835: DEC
6836: ST_TO_ADDR
6837: LD_VAR 0 5
6841: PUSH
6842: FOR_TO
6843: IFFALSE 7020
// begin if IsInUnit ( barrack [ i ] ) = 0 then
6845: LD_VAR 0 5
6849: PUSH
6850: LD_VAR 0 3
6854: ARRAY
6855: PPUSH
6856: CALL_OW 310
6860: PUSH
6861: LD_INT 0
6863: EQUAL
6864: IFFALSE 7018
// begin uc_side = side ;
6866: LD_ADDR_OWVAR 20
6870: PUSH
6871: LD_VAR 0 1
6875: ST_TO_ADDR
// for j = 1 to 2 do
6876: LD_ADDR_VAR 0 4
6880: PUSH
6881: DOUBLE
6882: LD_INT 1
6884: DEC
6885: ST_TO_ADDR
6886: LD_INT 2
6888: PUSH
6889: FOR_TO
6890: IFFALSE 6936
// begin PrepareSoldier ( 0 , RuSolMaxLevel ) ;
6892: LD_INT 0
6894: PPUSH
6895: LD_EXP 35
6899: PPUSH
6900: CALL_OW 381
// soldat := CreateHuman ;
6904: LD_ADDR_VAR 0 6
6908: PUSH
6909: CALL_OW 44
6913: ST_TO_ADDR
// PlaceHumanInUnit ( soldat , barrack [ i ] ) ;
6914: LD_VAR 0 6
6918: PPUSH
6919: LD_VAR 0 5
6923: PUSH
6924: LD_VAR 0 3
6928: ARRAY
6929: PPUSH
6930: CALL_OW 52
// end ;
6934: GO 6889
6936: POP
6937: POP
// if side = 3 then
6938: LD_VAR 0 1
6942: PUSH
6943: LD_INT 3
6945: EQUAL
6946: IFFALSE 7018
// for j = 1 to 2 do
6948: LD_ADDR_VAR 0 4
6952: PUSH
6953: DOUBLE
6954: LD_INT 1
6956: DEC
6957: ST_TO_ADDR
6958: LD_INT 2
6960: PUSH
6961: FOR_TO
6962: IFFALSE 7016
// begin PrepareSoldier ( 0 , RuSolMaxLevel ) ;
6964: LD_INT 0
6966: PPUSH
6967: LD_EXP 35
6971: PPUSH
6972: CALL_OW 381
// hc_class = class_bazooker ;
6976: LD_ADDR_OWVAR 28
6980: PUSH
6981: LD_INT 9
6983: ST_TO_ADDR
// soldat := CreateHuman ;
6984: LD_ADDR_VAR 0 6
6988: PUSH
6989: CALL_OW 44
6993: ST_TO_ADDR
// PlaceHumanInUnit ( soldat , barrack [ i ] ) ;
6994: LD_VAR 0 6
6998: PPUSH
6999: LD_VAR 0 5
7003: PUSH
7004: LD_VAR 0 3
7008: ARRAY
7009: PPUSH
7010: CALL_OW 52
// end ;
7014: GO 6961
7016: POP
7017: POP
// end ; end ;
7018: GO 6842
7020: POP
7021: POP
// end ;
7022: LD_VAR 0 2
7026: RET
// export function Assemble_Armories ( side ) ; var i , j , barrack , soldat , filter ; begin
7027: LD_INT 0
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
// case side of 1 :
7035: LD_VAR 0 1
7039: PUSH
7040: LD_INT 1
7042: DOUBLE
7043: EQUAL
7044: IFTRUE 7048
7046: GO 7059
7048: POP
// uc_nation = nation_american ; 3 :
7049: LD_ADDR_OWVAR 21
7053: PUSH
7054: LD_INT 1
7056: ST_TO_ADDR
7057: GO 7098
7059: LD_INT 3
7061: DOUBLE
7062: EQUAL
7063: IFTRUE 7067
7065: GO 7078
7067: POP
// uc_nation = nation_russian ; 6 :
7068: LD_ADDR_OWVAR 21
7072: PUSH
7073: LD_INT 3
7075: ST_TO_ADDR
7076: GO 7098
7078: LD_INT 6
7080: DOUBLE
7081: EQUAL
7082: IFTRUE 7086
7084: GO 7097
7086: POP
// uc_nation = nation_russian ; end ;
7087: LD_ADDR_OWVAR 21
7091: PUSH
7092: LD_INT 3
7094: ST_TO_ADDR
7095: GO 7098
7097: POP
// barrack := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_armoury ] ] ) ;
7098: LD_ADDR_VAR 0 5
7102: PUSH
7103: LD_INT 22
7105: PUSH
7106: LD_VAR 0 1
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: LD_INT 30
7117: PUSH
7118: LD_INT 4
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PPUSH
7129: CALL_OW 69
7133: ST_TO_ADDR
// for i = 1 to barrack do
7134: LD_ADDR_VAR 0 3
7138: PUSH
7139: DOUBLE
7140: LD_INT 1
7142: DEC
7143: ST_TO_ADDR
7144: LD_VAR 0 5
7148: PUSH
7149: FOR_TO
7150: IFFALSE 7319
// begin if IsInUnit ( barrack [ i ] ) = 0 then
7152: LD_VAR 0 5
7156: PUSH
7157: LD_VAR 0 3
7161: ARRAY
7162: PPUSH
7163: CALL_OW 310
7167: PUSH
7168: LD_INT 0
7170: EQUAL
7171: IFFALSE 7317
// begin uc_side = side ;
7173: LD_ADDR_OWVAR 20
7177: PUSH
7178: LD_VAR 0 1
7182: ST_TO_ADDR
// if side = 6 then
7183: LD_VAR 0 1
7187: PUSH
7188: LD_INT 6
7190: EQUAL
7191: IFFALSE 7255
// for j = 1 to 2 do
7193: LD_ADDR_VAR 0 4
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_INT 2
7205: PUSH
7206: FOR_TO
7207: IFFALSE 7251
// begin PrepareSoldier ( 0 , 5 ) ;
7209: LD_INT 0
7211: PPUSH
7212: LD_INT 5
7214: PPUSH
7215: CALL_OW 381
// soldat := CreateHuman ;
7219: LD_ADDR_VAR 0 6
7223: PUSH
7224: CALL_OW 44
7228: ST_TO_ADDR
// PlaceHumanInUnit ( soldat , barrack [ i ] ) ;
7229: LD_VAR 0 6
7233: PPUSH
7234: LD_VAR 0 5
7238: PUSH
7239: LD_VAR 0 3
7243: ARRAY
7244: PPUSH
7245: CALL_OW 52
// end else
7249: GO 7206
7251: POP
7252: POP
7253: GO 7317
// for j = 1 to 3 do
7255: LD_ADDR_VAR 0 4
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_INT 3
7267: PUSH
7268: FOR_TO
7269: IFFALSE 7315
// begin PrepareSoldier ( 0 , RuSolMaxLevel ) ;
7271: LD_INT 0
7273: PPUSH
7274: LD_EXP 35
7278: PPUSH
7279: CALL_OW 381
// soldat := CreateHuman ;
7283: LD_ADDR_VAR 0 6
7287: PUSH
7288: CALL_OW 44
7292: ST_TO_ADDR
// PlaceHumanInUnit ( soldat , barrack [ i ] ) ;
7293: LD_VAR 0 6
7297: PPUSH
7298: LD_VAR 0 5
7302: PUSH
7303: LD_VAR 0 3
7307: ARRAY
7308: PPUSH
7309: CALL_OW 52
// end ;
7313: GO 7268
7315: POP
7316: POP
// end ; end ;
7317: GO 7149
7319: POP
7320: POP
// end ;
7321: LD_VAR 0 2
7325: RET
// export function PlaceUnitInBunker ( un , b ) ; var dir ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
// dir := GetDir ( b ) ;
7330: LD_ADDR_VAR 0 4
7334: PUSH
7335: LD_VAR 0 2
7339: PPUSH
7340: CALL_OW 254
7344: ST_TO_ADDR
// if dir < 3 then
7345: LD_VAR 0 4
7349: PUSH
7350: LD_INT 3
7352: LESS
7353: IFFALSE 7371
// dir := dir + 3 else
7355: LD_ADDR_VAR 0 4
7359: PUSH
7360: LD_VAR 0 4
7364: PUSH
7365: LD_INT 3
7367: PLUS
7368: ST_TO_ADDR
7369: GO 7385
// dir := dir - 3 ;
7371: LD_ADDR_VAR 0 4
7375: PUSH
7376: LD_VAR 0 4
7380: PUSH
7381: LD_INT 3
7383: MINUS
7384: ST_TO_ADDR
// SetDir ( un , dir ) ;
7385: LD_VAR 0 1
7389: PPUSH
7390: LD_VAR 0 4
7394: PPUSH
7395: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
7399: LD_VAR 0 1
7403: PPUSH
7404: LD_VAR 0 2
7408: PPUSH
7409: CALL_OW 52
// end ;
7413: LD_VAR 0 3
7417: RET
// export function Fill_Bunkers ( side ) ; var i , filter , un ; begin
7418: LD_INT 0
7420: PPUSH
7421: PPUSH
7422: PPUSH
7423: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 3 ] , [ f_btype , b_breastwork ] ] ) ;
7424: LD_ADDR_VAR 0 4
7428: PUSH
7429: LD_INT 22
7431: PUSH
7432: LD_VAR 0 1
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PUSH
7441: LD_INT 23
7443: PUSH
7444: LD_INT 3
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: LD_INT 30
7453: PUSH
7454: LD_INT 31
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: LIST
7465: PPUSH
7466: CALL_OW 69
7470: ST_TO_ADDR
// for i = 1 to filter do
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: DOUBLE
7477: LD_INT 1
7479: DEC
7480: ST_TO_ADDR
7481: LD_VAR 0 4
7485: PUSH
7486: FOR_TO
7487: IFFALSE 7572
// if IsInUnit ( filter [ i ] ) = 0 then
7489: LD_VAR 0 4
7493: PUSH
7494: LD_VAR 0 3
7498: ARRAY
7499: PPUSH
7500: CALL_OW 310
7504: PUSH
7505: LD_INT 0
7507: EQUAL
7508: IFFALSE 7570
// begin uc_nation = nation_russian ;
7510: LD_ADDR_OWVAR 21
7514: PUSH
7515: LD_INT 3
7517: ST_TO_ADDR
// uc_side = side ;
7518: LD_ADDR_OWVAR 20
7522: PUSH
7523: LD_VAR 0 1
7527: ST_TO_ADDR
// PrepareSoldier ( 1 , RuSolMaxLevel ) ;
7528: LD_INT 1
7530: PPUSH
7531: LD_EXP 35
7535: PPUSH
7536: CALL_OW 381
// un := CreateHuman ;
7540: LD_ADDR_VAR 0 5
7544: PUSH
7545: CALL_OW 44
7549: ST_TO_ADDR
// PlaceUnitInBunker ( un , filter [ i ] ) ;
7550: LD_VAR 0 5
7554: PPUSH
7555: LD_VAR 0 4
7559: PUSH
7560: LD_VAR 0 3
7564: ARRAY
7565: PPUSH
7566: CALL 7326 0 2
// end ;
7570: GO 7486
7572: POP
7573: POP
// end ;
7574: LD_VAR 0 2
7578: RET
// export function Fill_Turrets ( side ) ; var i , filter , un ; begin
7579: LD_INT 0
7581: PPUSH
7582: PPUSH
7583: PPUSH
7584: PPUSH
// uc_side := side ;
7585: LD_ADDR_OWVAR 20
7589: PUSH
7590: LD_VAR 0 1
7594: ST_TO_ADDR
// uc_nation := 3 ;
7595: LD_ADDR_OWVAR 21
7599: PUSH
7600: LD_INT 3
7602: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) do
7603: LD_ADDR_VAR 0 3
7607: PUSH
7608: LD_INT 22
7610: PUSH
7611: LD_VAR 0 1
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: LD_INT 30
7622: PUSH
7623: LD_INT 32
7625: PUSH
7626: EMPTY
7627: LIST
7628: LIST
7629: PUSH
7630: LD_INT 58
7632: PUSH
7633: EMPTY
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: CALL_OW 69
7645: PUSH
7646: FOR_IN
7647: IFFALSE 7677
// begin PrepareSoldier ( 1 , RuSolMaxLevel ) ;
7649: LD_INT 1
7651: PPUSH
7652: LD_EXP 35
7656: PPUSH
7657: CALL_OW 381
// PlaceHumanInUnit ( CreateHuman , i ) ;
7661: CALL_OW 44
7665: PPUSH
7666: LD_VAR 0 3
7670: PPUSH
7671: CALL_OW 52
// end ;
7675: GO 7646
7677: POP
7678: POP
// end ;
7679: LD_VAR 0 2
7683: RET
// export function RussianMobile ( side , medium , heavy , area ) ; var i , veh , ru_veh_medium , ru_veh_heavy , auto ; begin
7684: LD_INT 0
7686: PPUSH
7687: PPUSH
7688: PPUSH
7689: PPUSH
7690: PPUSH
7691: PPUSH
// uc_nation = nation_russian ;
7692: LD_ADDR_OWVAR 21
7696: PUSH
7697: LD_INT 3
7699: ST_TO_ADDR
// uc_side = side ;
7700: LD_ADDR_OWVAR 20
7704: PUSH
7705: LD_VAR 0 1
7709: ST_TO_ADDR
// hc_name :=  ;
7710: LD_ADDR_OWVAR 26
7714: PUSH
7715: LD_STRING 
7717: ST_TO_ADDR
// hc_gallery :=  ;
7718: LD_ADDR_OWVAR 33
7722: PUSH
7723: LD_STRING 
7725: ST_TO_ADDR
// ru_veh_medium := [ [ ru_medium_wheeled , engine_siberite , ru_heavy_machine_gun , control_computer ] , [ ru_medium_tracked , engine_siberite , ru_heavy_machine_gun , control_computer ] , [ ru_medium_tracked , engine_siberite , ru_gatling_gun , control_computer ] , [ ru_medium_wheeled , engine_siberite , ru_gatling_gun , control_computer ] , [ ru_medium_wheeled , engine_siberite , ru_gun , control_computer ] , [ ru_medium_tracked , engine_siberite , ru_gun , control_computer ] , [ ru_medium_tracked , engine_siberite , ru_rocket_launcher , control_computer ] ] ;
7726: LD_ADDR_VAR 0 8
7730: PUSH
7731: LD_INT 21
7733: PUSH
7734: LD_INT 3
7736: PUSH
7737: LD_INT 42
7739: PUSH
7740: LD_INT 3
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 22
7751: PUSH
7752: LD_INT 3
7754: PUSH
7755: LD_INT 42
7757: PUSH
7758: LD_INT 3
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: PUSH
7767: LD_INT 22
7769: PUSH
7770: LD_INT 3
7772: PUSH
7773: LD_INT 43
7775: PUSH
7776: LD_INT 3
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: PUSH
7785: LD_INT 21
7787: PUSH
7788: LD_INT 3
7790: PUSH
7791: LD_INT 43
7793: PUSH
7794: LD_INT 3
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: LIST
7801: LIST
7802: PUSH
7803: LD_INT 21
7805: PUSH
7806: LD_INT 3
7808: PUSH
7809: LD_INT 44
7811: PUSH
7812: LD_INT 3
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 22
7823: PUSH
7824: LD_INT 3
7826: PUSH
7827: LD_INT 44
7829: PUSH
7830: LD_INT 3
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: PUSH
7839: LD_INT 22
7841: PUSH
7842: LD_INT 3
7844: PUSH
7845: LD_INT 45
7847: PUSH
7848: LD_INT 3
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: ST_TO_ADDR
// ru_veh_heavy := [ [ ru_heavy_wheeled , engine_siberite , ru_gatling_gun , control_computer ] , [ ru_heavy_wheeled , engine_siberite , ru_gun , control_computer ] , [ ru_heavy_tracked , engine_siberite , ru_gatling_gun , control_computer ] , [ ru_heavy_tracked , engine_siberite , ru_gun , control_computer ] , [ ru_heavy_tracked , engine_siberite , ru_heavy_gun , control_computer ] ] ;
7866: LD_ADDR_VAR 0 9
7870: PUSH
7871: LD_INT 23
7873: PUSH
7874: LD_INT 3
7876: PUSH
7877: LD_INT 43
7879: PUSH
7880: LD_INT 3
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 23
7891: PUSH
7892: LD_INT 3
7894: PUSH
7895: LD_INT 44
7897: PUSH
7898: LD_INT 3
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 24
7909: PUSH
7910: LD_INT 3
7912: PUSH
7913: LD_INT 43
7915: PUSH
7916: LD_INT 3
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 24
7927: PUSH
7928: LD_INT 3
7930: PUSH
7931: LD_INT 44
7933: PUSH
7934: LD_INT 3
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: PUSH
7943: LD_INT 24
7945: PUSH
7946: LD_INT 3
7948: PUSH
7949: LD_INT 46
7951: PUSH
7952: LD_INT 3
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: ST_TO_ADDR
// for i = 1 to medium do
7968: LD_ADDR_VAR 0 6
7972: PUSH
7973: DOUBLE
7974: LD_INT 1
7976: DEC
7977: ST_TO_ADDR
7978: LD_VAR 0 2
7982: PUSH
7983: FOR_TO
7984: IFFALSE 8117
// begin auto := Rand ( 1 , ( 0 + ru_veh_medium ) ) ;
7986: LD_ADDR_VAR 0 10
7990: PUSH
7991: LD_INT 1
7993: PPUSH
7994: LD_INT 0
7996: PUSH
7997: LD_VAR 0 8
8001: PLUS
8002: PPUSH
8003: CALL_OW 12
8007: ST_TO_ADDR
// vc_chassis := ru_veh_medium [ auto ] [ 1 ] ;
8008: LD_ADDR_OWVAR 37
8012: PUSH
8013: LD_VAR 0 8
8017: PUSH
8018: LD_VAR 0 10
8022: ARRAY
8023: PUSH
8024: LD_INT 1
8026: ARRAY
8027: ST_TO_ADDR
// vc_engine := ru_veh_medium [ auto ] [ 2 ] ;
8028: LD_ADDR_OWVAR 39
8032: PUSH
8033: LD_VAR 0 8
8037: PUSH
8038: LD_VAR 0 10
8042: ARRAY
8043: PUSH
8044: LD_INT 2
8046: ARRAY
8047: ST_TO_ADDR
// vc_weapon := ru_veh_medium [ auto ] [ 3 ] ;
8048: LD_ADDR_OWVAR 40
8052: PUSH
8053: LD_VAR 0 8
8057: PUSH
8058: LD_VAR 0 10
8062: ARRAY
8063: PUSH
8064: LD_INT 3
8066: ARRAY
8067: ST_TO_ADDR
// vc_control := ru_veh_medium [ auto ] [ 4 ] ;
8068: LD_ADDR_OWVAR 38
8072: PUSH
8073: LD_VAR 0 8
8077: PUSH
8078: LD_VAR 0 10
8082: ARRAY
8083: PUSH
8084: LD_INT 4
8086: ARRAY
8087: ST_TO_ADDR
// veh := CreateVehicle ;
8088: LD_ADDR_VAR 0 7
8092: PUSH
8093: CALL_OW 45
8097: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
8098: LD_VAR 0 7
8102: PPUSH
8103: LD_VAR 0 4
8107: PPUSH
8108: LD_INT 0
8110: PPUSH
8111: CALL_OW 49
// end ;
8115: GO 7983
8117: POP
8118: POP
// for i = 1 to heavy do
8119: LD_ADDR_VAR 0 6
8123: PUSH
8124: DOUBLE
8125: LD_INT 1
8127: DEC
8128: ST_TO_ADDR
8129: LD_VAR 0 3
8133: PUSH
8134: FOR_TO
8135: IFFALSE 8268
// begin auto := Rand ( 1 , ( 0 + ru_veh_heavy ) ) ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 1
8144: PPUSH
8145: LD_INT 0
8147: PUSH
8148: LD_VAR 0 9
8152: PLUS
8153: PPUSH
8154: CALL_OW 12
8158: ST_TO_ADDR
// vc_chassis := ru_veh_heavy [ auto ] [ 1 ] ;
8159: LD_ADDR_OWVAR 37
8163: PUSH
8164: LD_VAR 0 9
8168: PUSH
8169: LD_VAR 0 10
8173: ARRAY
8174: PUSH
8175: LD_INT 1
8177: ARRAY
8178: ST_TO_ADDR
// vc_engine := ru_veh_heavy [ auto ] [ 2 ] ;
8179: LD_ADDR_OWVAR 39
8183: PUSH
8184: LD_VAR 0 9
8188: PUSH
8189: LD_VAR 0 10
8193: ARRAY
8194: PUSH
8195: LD_INT 2
8197: ARRAY
8198: ST_TO_ADDR
// vc_weapon := ru_veh_heavy [ auto ] [ 3 ] ;
8199: LD_ADDR_OWVAR 40
8203: PUSH
8204: LD_VAR 0 9
8208: PUSH
8209: LD_VAR 0 10
8213: ARRAY
8214: PUSH
8215: LD_INT 3
8217: ARRAY
8218: ST_TO_ADDR
// vc_control := ru_veh_heavy [ auto ] [ 4 ] ;
8219: LD_ADDR_OWVAR 38
8223: PUSH
8224: LD_VAR 0 9
8228: PUSH
8229: LD_VAR 0 10
8233: ARRAY
8234: PUSH
8235: LD_INT 4
8237: ARRAY
8238: ST_TO_ADDR
// veh := CreateVehicle ;
8239: LD_ADDR_VAR 0 7
8243: PUSH
8244: CALL_OW 45
8248: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
8249: LD_VAR 0 7
8253: PPUSH
8254: LD_VAR 0 4
8258: PPUSH
8259: LD_INT 0
8261: PPUSH
8262: CALL_OW 49
// end ;
8266: GO 8134
8268: POP
8269: POP
// end ;
8270: LD_VAR 0 5
8274: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , target1 , target2 ; begin
8275: LD_INT 0
8277: PPUSH
8278: PPUSH
8279: PPUSH
8280: PPUSH
8281: PPUSH
8282: PPUSH
8283: PPUSH
8284: PPUSH
8285: PPUSH
8286: PPUSH
// amChassisTab = [ ] ;
8287: LD_ADDR_VAR 0 18
8291: PUSH
8292: EMPTY
8293: ST_TO_ADDR
// arChassisTab = [ ] ;
8294: LD_ADDR_VAR 0 17
8298: PUSH
8299: EMPTY
8300: ST_TO_ADDR
// ruChassisTab = [ ] ;
8301: LD_ADDR_VAR 0 16
8305: PUSH
8306: EMPTY
8307: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8308: LD_INT 35
8310: PPUSH
8311: CALL_OW 67
// if nation = 1 then
8315: LD_VAR 0 5
8319: PUSH
8320: LD_INT 1
8322: EQUAL
8323: IFFALSE 8844
// begin uc_side = side ;
8325: LD_ADDR_OWVAR 20
8329: PUSH
8330: LD_VAR 0 2
8334: ST_TO_ADDR
// uc_nation = nation ;
8335: LD_ADDR_OWVAR 21
8339: PUSH
8340: LD_VAR 0 5
8344: ST_TO_ADDR
// vc_engine = vehengine ;
8345: LD_ADDR_OWVAR 39
8349: PUSH
8350: LD_VAR 0 6
8354: ST_TO_ADDR
// vc_control = vehControl [ Rand ( 1 , vehControl ) ] ;
8355: LD_ADDR_OWVAR 38
8359: PUSH
8360: LD_VAR 0 7
8364: PUSH
8365: LD_INT 1
8367: PPUSH
8368: LD_VAR 0 7
8372: PPUSH
8373: CALL_OW 12
8377: ARRAY
8378: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
8379: LD_ADDR_OWVAR 40
8383: PUSH
8384: LD_VAR 0 10
8388: PUSH
8389: LD_INT 1
8391: PPUSH
8392: LD_VAR 0 10
8396: PPUSH
8397: CALL_OW 12
8401: ARRAY
8402: ST_TO_ADDR
// for j = 1 to AMWeapon do
8403: LD_ADDR_VAR 0 13
8407: PUSH
8408: DOUBLE
8409: LD_INT 1
8411: DEC
8412: ST_TO_ADDR
8413: LD_VAR 0 10
8417: PUSH
8418: FOR_TO
8419: IFFALSE 8720
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
8421: LD_VAR 0 10
8425: PUSH
8426: LD_VAR 0 13
8430: ARRAY
8431: PUSH
8432: LD_INT 2
8434: EQUAL
8435: PUSH
8436: LD_VAR 0 10
8440: PUSH
8441: LD_VAR 0 13
8445: ARRAY
8446: PUSH
8447: LD_INT 3
8449: EQUAL
8450: OR
8451: IFFALSE 8504
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
8453: LD_ADDR_VAR 0 18
8457: PUSH
8458: LD_INT 1
8460: PUSH
8461: LD_INT 2
8463: PUSH
8464: LD_INT 3
8466: PUSH
8467: LD_INT 4
8469: PUSH
8470: LD_INT 5
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: LIST
8478: LIST
8479: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
8480: LD_ADDR_OWVAR 37
8484: PUSH
8485: LD_VAR 0 18
8489: PUSH
8490: LD_INT 1
8492: PPUSH
8493: LD_VAR 0 18
8497: PPUSH
8498: CALL_OW 12
8502: ARRAY
8503: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
8504: LD_VAR 0 10
8508: PUSH
8509: LD_VAR 0 13
8513: ARRAY
8514: PUSH
8515: LD_INT 4
8517: EQUAL
8518: PUSH
8519: LD_VAR 0 10
8523: PUSH
8524: LD_VAR 0 13
8528: ARRAY
8529: PUSH
8530: LD_INT 5
8532: EQUAL
8533: OR
8534: PUSH
8535: LD_VAR 0 10
8539: PUSH
8540: LD_VAR 0 13
8544: ARRAY
8545: PUSH
8546: LD_INT 9
8548: EQUAL
8549: OR
8550: PUSH
8551: LD_VAR 0 10
8555: PUSH
8556: LD_VAR 0 13
8560: ARRAY
8561: PUSH
8562: LD_INT 11
8564: EQUAL
8565: OR
8566: PUSH
8567: LD_VAR 0 10
8571: PUSH
8572: LD_VAR 0 13
8576: ARRAY
8577: PUSH
8578: LD_INT 7
8580: EQUAL
8581: OR
8582: IFFALSE 8631
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
8584: LD_ADDR_VAR 0 18
8588: PUSH
8589: LD_INT 2
8591: PUSH
8592: LD_INT 3
8594: PUSH
8595: LD_INT 4
8597: PUSH
8598: LD_INT 5
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
8607: LD_ADDR_OWVAR 37
8611: PUSH
8612: LD_VAR 0 18
8616: PUSH
8617: LD_INT 1
8619: PPUSH
8620: LD_VAR 0 18
8624: PPUSH
8625: CALL_OW 12
8629: ARRAY
8630: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
8631: LD_VAR 0 10
8635: PUSH
8636: LD_VAR 0 13
8640: ARRAY
8641: PUSH
8642: LD_INT 8
8644: EQUAL
8645: PUSH
8646: LD_VAR 0 10
8650: PUSH
8651: LD_VAR 0 13
8655: ARRAY
8656: PUSH
8657: LD_INT 6
8659: EQUAL
8660: OR
8661: PUSH
8662: LD_VAR 0 10
8666: PUSH
8667: LD_VAR 0 13
8671: ARRAY
8672: PUSH
8673: LD_INT 10
8675: EQUAL
8676: OR
8677: IFFALSE 8718
// begin amChassisTab = [ 4 , 5 ] ;
8679: LD_ADDR_VAR 0 18
8683: PUSH
8684: LD_INT 4
8686: PUSH
8687: LD_INT 5
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
8694: LD_ADDR_OWVAR 37
8698: PUSH
8699: LD_VAR 0 18
8703: PUSH
8704: LD_INT 1
8706: PPUSH
8707: LD_VAR 0 18
8711: PPUSH
8712: CALL_OW 12
8716: ARRAY
8717: ST_TO_ADDR
// end ; end ;
8718: GO 8418
8720: POP
8721: POP
// veh = CreateVehicle ;
8722: LD_ADDR_VAR 0 15
8726: PUSH
8727: CALL_OW 45
8731: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
8732: LD_VAR 0 15
8736: PPUSH
8737: LD_VAR 0 1
8741: PPUSH
8742: LD_INT 0
8744: PPUSH
8745: CALL_OW 49
// if vc_control = 1 then
8749: LD_OWVAR 38
8753: PUSH
8754: LD_INT 1
8756: EQUAL
8757: IFFALSE 8814
// begin hc_gallery =  ;
8759: LD_ADDR_OWVAR 33
8763: PUSH
8764: LD_STRING 
8766: ST_TO_ADDR
// hc_name =  ;
8767: LD_ADDR_OWVAR 26
8771: PUSH
8772: LD_STRING 
8774: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
8775: LD_INT 0
8777: PPUSH
8778: LD_INT 3
8780: PPUSH
8781: LD_VAR 0 4
8785: PPUSH
8786: CALL_OW 380
// un = CreateHuman ;
8790: LD_ADDR_VAR 0 14
8794: PUSH
8795: CALL_OW 44
8799: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8800: LD_VAR 0 14
8804: PPUSH
8805: LD_VAR 0 15
8809: PPUSH
8810: CALL_OW 52
// end ; attack_group = attack_group ^ veh ;
8814: LD_ADDR_EXP 47
8818: PUSH
8819: LD_EXP 47
8823: PUSH
8824: LD_VAR 0 15
8828: ADD
8829: ST_TO_ADDR
// i = i + 1 ;
8830: LD_ADDR_VAR 0 12
8834: PUSH
8835: LD_VAR 0 12
8839: PUSH
8840: LD_INT 1
8842: PLUS
8843: ST_TO_ADDR
// end ; if nation = 2 then
8844: LD_VAR 0 5
8848: PUSH
8849: LD_INT 2
8851: EQUAL
8852: IFFALSE 9377
// begin uc_side = side ;
8854: LD_ADDR_OWVAR 20
8858: PUSH
8859: LD_VAR 0 2
8863: ST_TO_ADDR
// uc_nation = nation ;
8864: LD_ADDR_OWVAR 21
8868: PUSH
8869: LD_VAR 0 5
8873: ST_TO_ADDR
// vc_engine = vehengine ;
8874: LD_ADDR_OWVAR 39
8878: PUSH
8879: LD_VAR 0 6
8883: ST_TO_ADDR
// vc_control = vehControl [ Rand ( 1 , vehControl ) ] ;
8884: LD_ADDR_OWVAR 38
8888: PUSH
8889: LD_VAR 0 7
8893: PUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_VAR 0 7
8901: PPUSH
8902: CALL_OW 12
8906: ARRAY
8907: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
8908: LD_ADDR_OWVAR 40
8912: PUSH
8913: LD_VAR 0 9
8917: PUSH
8918: LD_INT 1
8920: PPUSH
8921: LD_VAR 0 9
8925: PPUSH
8926: CALL_OW 12
8930: ARRAY
8931: ST_TO_ADDR
// for j = 1 to ARWeapons do
8932: LD_ADDR_VAR 0 13
8936: PUSH
8937: DOUBLE
8938: LD_INT 1
8940: DEC
8941: ST_TO_ADDR
8942: LD_VAR 0 9
8946: PUSH
8947: FOR_TO
8948: IFFALSE 9253
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
8950: LD_VAR 0 9
8954: PUSH
8955: LD_VAR 0 13
8959: ARRAY
8960: PUSH
8961: LD_INT 24
8963: EQUAL
8964: PUSH
8965: LD_VAR 0 9
8969: PUSH
8970: LD_VAR 0 13
8974: ARRAY
8975: PUSH
8976: LD_INT 22
8978: EQUAL
8979: OR
8980: PUSH
8981: LD_VAR 0 9
8985: PUSH
8986: LD_VAR 0 13
8990: ARRAY
8991: PUSH
8992: LD_INT 23
8994: EQUAL
8995: OR
8996: PUSH
8997: LD_VAR 0 9
9001: PUSH
9002: LD_VAR 0 13
9006: ARRAY
9007: PUSH
9008: LD_INT 30
9010: EQUAL
9011: OR
9012: IFFALSE 9049
// begin arChassisTab = [ 14 ] ;
9014: LD_ADDR_VAR 0 17
9018: PUSH
9019: LD_INT 14
9021: PUSH
9022: EMPTY
9023: LIST
9024: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
9025: LD_ADDR_OWVAR 37
9029: PUSH
9030: LD_VAR 0 17
9034: PUSH
9035: LD_INT 1
9037: PPUSH
9038: LD_VAR 0 17
9042: PPUSH
9043: CALL_OW 12
9047: ARRAY
9048: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
9049: LD_VAR 0 9
9053: PUSH
9054: LD_VAR 0 13
9058: ARRAY
9059: PUSH
9060: LD_INT 29
9062: EQUAL
9063: PUSH
9064: LD_VAR 0 9
9068: PUSH
9069: LD_VAR 0 13
9073: ARRAY
9074: PUSH
9075: LD_INT 28
9077: EQUAL
9078: OR
9079: PUSH
9080: LD_VAR 0 9
9084: PUSH
9085: LD_VAR 0 13
9089: ARRAY
9090: PUSH
9091: LD_INT 27
9093: EQUAL
9094: OR
9095: PUSH
9096: LD_VAR 0 9
9100: PUSH
9101: LD_VAR 0 13
9105: ARRAY
9106: PUSH
9107: LD_INT 26
9109: EQUAL
9110: OR
9111: PUSH
9112: LD_VAR 0 9
9116: PUSH
9117: LD_VAR 0 13
9121: ARRAY
9122: PUSH
9123: LD_INT 25
9125: EQUAL
9126: OR
9127: IFFALSE 9168
// begin arChassisTab = [ 14 , 16 ] ;
9129: LD_ADDR_VAR 0 17
9133: PUSH
9134: LD_INT 14
9136: PUSH
9137: LD_INT 16
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
9144: LD_ADDR_OWVAR 37
9148: PUSH
9149: LD_VAR 0 17
9153: PUSH
9154: LD_INT 1
9156: PPUSH
9157: LD_VAR 0 17
9161: PPUSH
9162: CALL_OW 12
9166: ARRAY
9167: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 72 or ARWeapons [ j ] = 73 or ARWeapons [ j ] = 71 then
9168: LD_VAR 0 9
9172: PUSH
9173: LD_VAR 0 13
9177: ARRAY
9178: PUSH
9179: LD_INT 72
9181: EQUAL
9182: PUSH
9183: LD_VAR 0 9
9187: PUSH
9188: LD_VAR 0 13
9192: ARRAY
9193: PUSH
9194: LD_INT 73
9196: EQUAL
9197: OR
9198: PUSH
9199: LD_VAR 0 9
9203: PUSH
9204: LD_VAR 0 13
9208: ARRAY
9209: PUSH
9210: LD_INT 71
9212: EQUAL
9213: OR
9214: IFFALSE 9251
// begin arChassisTab = [ 16 ] ;
9216: LD_ADDR_VAR 0 17
9220: PUSH
9221: LD_INT 16
9223: PUSH
9224: EMPTY
9225: LIST
9226: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
9227: LD_ADDR_OWVAR 37
9231: PUSH
9232: LD_VAR 0 17
9236: PUSH
9237: LD_INT 1
9239: PPUSH
9240: LD_VAR 0 17
9244: PPUSH
9245: CALL_OW 12
9249: ARRAY
9250: ST_TO_ADDR
// end ; end ;
9251: GO 8947
9253: POP
9254: POP
// veh = CreateVehicle ;
9255: LD_ADDR_VAR 0 15
9259: PUSH
9260: CALL_OW 45
9264: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
9265: LD_VAR 0 15
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_INT 0
9277: PPUSH
9278: CALL_OW 49
// if vc_control = 1 then
9282: LD_OWVAR 38
9286: PUSH
9287: LD_INT 1
9289: EQUAL
9290: IFFALSE 9347
// begin hc_gallery =  ;
9292: LD_ADDR_OWVAR 33
9296: PUSH
9297: LD_STRING 
9299: ST_TO_ADDR
// hc_name =  ;
9300: LD_ADDR_OWVAR 26
9304: PUSH
9305: LD_STRING 
9307: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
9308: LD_INT 0
9310: PPUSH
9311: LD_INT 3
9313: PPUSH
9314: LD_VAR 0 4
9318: PPUSH
9319: CALL_OW 380
// un = CreateHuman ;
9323: LD_ADDR_VAR 0 14
9327: PUSH
9328: CALL_OW 44
9332: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
9333: LD_VAR 0 14
9337: PPUSH
9338: LD_VAR 0 15
9342: PPUSH
9343: CALL_OW 52
// end ; attack_group = attack_group ^ veh ;
9347: LD_ADDR_EXP 47
9351: PUSH
9352: LD_EXP 47
9356: PUSH
9357: LD_VAR 0 15
9361: ADD
9362: ST_TO_ADDR
// i = i + 1 ;
9363: LD_ADDR_VAR 0 12
9367: PUSH
9368: LD_VAR 0 12
9372: PUSH
9373: LD_INT 1
9375: PLUS
9376: ST_TO_ADDR
// end ; if nation = 3 then
9377: LD_VAR 0 5
9381: PUSH
9382: LD_INT 3
9384: EQUAL
9385: IFFALSE 9807
// begin uc_side = side ;
9387: LD_ADDR_OWVAR 20
9391: PUSH
9392: LD_VAR 0 2
9396: ST_TO_ADDR
// uc_nation = nation ;
9397: LD_ADDR_OWVAR 21
9401: PUSH
9402: LD_VAR 0 5
9406: ST_TO_ADDR
// vc_engine = vehengine ;
9407: LD_ADDR_OWVAR 39
9411: PUSH
9412: LD_VAR 0 6
9416: ST_TO_ADDR
// vc_control = vehControl [ Rand ( 1 , vehControl ) ] ;
9417: LD_ADDR_OWVAR 38
9421: PUSH
9422: LD_VAR 0 7
9426: PUSH
9427: LD_INT 1
9429: PPUSH
9430: LD_VAR 0 7
9434: PPUSH
9435: CALL_OW 12
9439: ARRAY
9440: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
9441: LD_ADDR_OWVAR 40
9445: PUSH
9446: LD_VAR 0 8
9450: PUSH
9451: LD_INT 1
9453: PPUSH
9454: LD_VAR 0 8
9458: PPUSH
9459: CALL_OW 12
9463: ARRAY
9464: ST_TO_ADDR
// for j = 1 to RuWeapons do
9465: LD_ADDR_VAR 0 13
9469: PUSH
9470: DOUBLE
9471: LD_INT 1
9473: DEC
9474: ST_TO_ADDR
9475: LD_VAR 0 8
9479: PUSH
9480: FOR_TO
9481: IFFALSE 9683
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
9483: LD_VAR 0 8
9487: PUSH
9488: LD_VAR 0 13
9492: ARRAY
9493: PUSH
9494: LD_INT 42
9496: EQUAL
9497: PUSH
9498: LD_VAR 0 8
9502: PUSH
9503: LD_VAR 0 13
9507: ARRAY
9508: PUSH
9509: LD_INT 43
9511: EQUAL
9512: OR
9513: PUSH
9514: LD_VAR 0 8
9518: PUSH
9519: LD_VAR 0 13
9523: ARRAY
9524: PUSH
9525: LD_INT 44
9527: EQUAL
9528: OR
9529: PUSH
9530: LD_VAR 0 8
9534: PUSH
9535: LD_VAR 0 13
9539: ARRAY
9540: PUSH
9541: LD_INT 45
9543: EQUAL
9544: OR
9545: PUSH
9546: LD_VAR 0 8
9550: PUSH
9551: LD_VAR 0 13
9555: ARRAY
9556: PUSH
9557: LD_INT 49
9559: EQUAL
9560: OR
9561: IFFALSE 9610
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
9563: LD_ADDR_VAR 0 16
9567: PUSH
9568: LD_INT 21
9570: PUSH
9571: LD_INT 22
9573: PUSH
9574: LD_INT 23
9576: PUSH
9577: LD_INT 24
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
9586: LD_ADDR_OWVAR 37
9590: PUSH
9591: LD_VAR 0 16
9595: PUSH
9596: LD_INT 1
9598: PPUSH
9599: LD_VAR 0 16
9603: PPUSH
9604: CALL_OW 12
9608: ARRAY
9609: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
9610: LD_VAR 0 8
9614: PUSH
9615: LD_VAR 0 13
9619: ARRAY
9620: PUSH
9621: LD_INT 46
9623: EQUAL
9624: PUSH
9625: LD_VAR 0 8
9629: PUSH
9630: LD_VAR 0 13
9634: ARRAY
9635: PUSH
9636: LD_INT 47
9638: EQUAL
9639: OR
9640: IFFALSE 9681
// begin ruChassisTab = [ 23 , 24 ] ;
9642: LD_ADDR_VAR 0 16
9646: PUSH
9647: LD_INT 23
9649: PUSH
9650: LD_INT 24
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
9657: LD_ADDR_OWVAR 37
9661: PUSH
9662: LD_VAR 0 16
9666: PUSH
9667: LD_INT 1
9669: PPUSH
9670: LD_VAR 0 16
9674: PPUSH
9675: CALL_OW 12
9679: ARRAY
9680: ST_TO_ADDR
// end ; end ;
9681: GO 9480
9683: POP
9684: POP
// veh = CreateVehicle ;
9685: LD_ADDR_VAR 0 15
9689: PUSH
9690: CALL_OW 45
9694: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
9695: LD_VAR 0 15
9699: PPUSH
9700: LD_VAR 0 1
9704: PPUSH
9705: LD_INT 0
9707: PPUSH
9708: CALL_OW 49
// if vc_control = 1 then
9712: LD_OWVAR 38
9716: PUSH
9717: LD_INT 1
9719: EQUAL
9720: IFFALSE 9777
// begin hc_gallery =  ;
9722: LD_ADDR_OWVAR 33
9726: PUSH
9727: LD_STRING 
9729: ST_TO_ADDR
// hc_name =  ;
9730: LD_ADDR_OWVAR 26
9734: PUSH
9735: LD_STRING 
9737: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
9738: LD_INT 0
9740: PPUSH
9741: LD_INT 3
9743: PPUSH
9744: LD_VAR 0 4
9748: PPUSH
9749: CALL_OW 380
// un = CreateHuman ;
9753: LD_ADDR_VAR 0 14
9757: PUSH
9758: CALL_OW 44
9762: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
9763: LD_VAR 0 14
9767: PPUSH
9768: LD_VAR 0 15
9772: PPUSH
9773: CALL_OW 52
// end ; attack_group = attack_group ^ veh ;
9777: LD_ADDR_EXP 47
9781: PUSH
9782: LD_EXP 47
9786: PUSH
9787: LD_VAR 0 15
9791: ADD
9792: ST_TO_ADDR
// i = i + 1 ;
9793: LD_ADDR_VAR 0 12
9797: PUSH
9798: LD_VAR 0 12
9802: PUSH
9803: LD_INT 1
9805: PLUS
9806: ST_TO_ADDR
// end ; until i = vehCount ;
9807: LD_VAR 0 12
9811: PUSH
9812: LD_VAR 0 3
9816: EQUAL
9817: IFFALSE 8308
// end ;
9819: LD_VAR 0 11
9823: RET
// export function SimoneCommandIssue ; begin
9824: LD_INT 0
9826: PPUSH
// case Rand ( 1 , 3 ) of 1 :
9827: LD_INT 1
9829: PPUSH
9830: LD_INT 3
9832: PPUSH
9833: CALL_OW 12
9837: PUSH
9838: LD_INT 1
9840: DOUBLE
9841: EQUAL
9842: IFTRUE 9846
9844: GO 9861
9846: POP
// Say ( Simone , DCommandIssue-Simone-1 ) ; 2 :
9847: LD_EXP 6
9851: PPUSH
9852: LD_STRING DCommandIssue-Simone-1
9854: PPUSH
9855: CALL_OW 88
9859: GO 9908
9861: LD_INT 2
9863: DOUBLE
9864: EQUAL
9865: IFTRUE 9869
9867: GO 9884
9869: POP
// Say ( Simone , DCommandIssue-Simone-2 ) ; 3 :
9870: LD_EXP 6
9874: PPUSH
9875: LD_STRING DCommandIssue-Simone-2
9877: PPUSH
9878: CALL_OW 88
9882: GO 9908
9884: LD_INT 3
9886: DOUBLE
9887: EQUAL
9888: IFTRUE 9892
9890: GO 9907
9892: POP
// Say ( Simone , DCommandIssue-Simone-3 ) ; end ;
9893: LD_EXP 6
9897: PPUSH
9898: LD_STRING DCommandIssue-Simone-3
9900: PPUSH
9901: CALL_OW 88
9905: GO 9908
9907: POP
// end ;
9908: LD_VAR 0 1
9912: RET
// export function SimoneCommandTacticsIssue ; begin
9913: LD_INT 0
9915: PPUSH
// case Rand ( 1 , 3 ) of 1 :
9916: LD_INT 1
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: CALL_OW 12
9926: PUSH
9927: LD_INT 1
9929: DOUBLE
9930: EQUAL
9931: IFTRUE 9935
9933: GO 9950
9935: POP
// Say ( Simone , DCommandTactics-Simone-1 ) ; 2 :
9936: LD_EXP 6
9940: PPUSH
9941: LD_STRING DCommandTactics-Simone-1
9943: PPUSH
9944: CALL_OW 88
9948: GO 9997
9950: LD_INT 2
9952: DOUBLE
9953: EQUAL
9954: IFTRUE 9958
9956: GO 9973
9958: POP
// Say ( Simone , DCommandTactics-Simone-2 ) ; 3 :
9959: LD_EXP 6
9963: PPUSH
9964: LD_STRING DCommandTactics-Simone-2
9966: PPUSH
9967: CALL_OW 88
9971: GO 9997
9973: LD_INT 3
9975: DOUBLE
9976: EQUAL
9977: IFTRUE 9981
9979: GO 9996
9981: POP
// Say ( Simone , DCommandTactics-Simone-3 ) ; end ;
9982: LD_EXP 6
9986: PPUSH
9987: LD_STRING DCommandTactics-Simone-3
9989: PPUSH
9990: CALL_OW 88
9994: GO 9997
9996: POP
// end ;
9997: LD_VAR 0 1
10001: RET
// export function KathrynCommandAcknowledge ; begin
10002: LD_INT 0
10004: PPUSH
// case Rand ( 1 , 5 ) of 1 :
10005: LD_INT 1
10007: PPUSH
10008: LD_INT 5
10010: PPUSH
10011: CALL_OW 12
10015: PUSH
10016: LD_INT 1
10018: DOUBLE
10019: EQUAL
10020: IFTRUE 10024
10022: GO 10039
10024: POP
// SayRadio ( Kathryn , DCommandAcknowledge-Kathryn-1 ) ; 2 :
10025: LD_EXP 7
10029: PPUSH
10030: LD_STRING DCommandAcknowledge-Kathryn-1
10032: PPUSH
10033: CALL_OW 94
10037: GO 10132
10039: LD_INT 2
10041: DOUBLE
10042: EQUAL
10043: IFTRUE 10047
10045: GO 10062
10047: POP
// SayRadio ( Kathryn , DCommandAcknowledge-Kathryn-2 ) ; 3 :
10048: LD_EXP 7
10052: PPUSH
10053: LD_STRING DCommandAcknowledge-Kathryn-2
10055: PPUSH
10056: CALL_OW 94
10060: GO 10132
10062: LD_INT 3
10064: DOUBLE
10065: EQUAL
10066: IFTRUE 10070
10068: GO 10085
10070: POP
// SayRadio ( Kathryn , DCommandAcknowledge-Kathryn-3 ) ; 4 :
10071: LD_EXP 7
10075: PPUSH
10076: LD_STRING DCommandAcknowledge-Kathryn-3
10078: PPUSH
10079: CALL_OW 94
10083: GO 10132
10085: LD_INT 4
10087: DOUBLE
10088: EQUAL
10089: IFTRUE 10093
10091: GO 10108
10093: POP
// SayRadio ( Kathryn , DCommandAcknowledge-Kathryn-4 ) ; 5 :
10094: LD_EXP 7
10098: PPUSH
10099: LD_STRING DCommandAcknowledge-Kathryn-4
10101: PPUSH
10102: CALL_OW 94
10106: GO 10132
10108: LD_INT 5
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10131
10116: POP
// SayRadio ( Kathryn , DCommandAcknowledge-Kathryn-5 ) ; end ;
10117: LD_EXP 7
10121: PPUSH
10122: LD_STRING DCommandAcknowledge-Kathryn-5
10124: PPUSH
10125: CALL_OW 94
10129: GO 10132
10131: POP
// end ;
10132: LD_VAR 0 1
10136: RET
// export function SaySex ( unit , dialogM , dialogF ) ; begin
10137: LD_INT 0
10139: PPUSH
// if not unit then
10140: LD_VAR 0 1
10144: NOT
10145: IFFALSE 10149
// exit ;
10147: GO 10183
// Say ( unit , [ dialogM , dialogF ] [ GetSex ( unit ) ] ) ;
10149: LD_VAR 0 1
10153: PPUSH
10154: LD_VAR 0 2
10158: PUSH
10159: LD_VAR 0 3
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: CALL_OW 258
10177: ARRAY
10178: PPUSH
10179: CALL_OW 88
// end ;
10183: LD_VAR 0 4
10187: RET
// export function EndMission ; var Vehicles , filter , i ; begin
10188: LD_INT 0
10190: PPUSH
10191: PPUSH
10192: PPUSH
10193: PPUSH
// Wait ( 0 0$1 ) ;
10194: LD_INT 35
10196: PPUSH
10197: CALL_OW 67
// Vehicles := [ ] ;
10201: LD_ADDR_VAR 0 2
10205: PUSH
10206: EMPTY
10207: ST_TO_ADDR
// if not KathrynLostControl and KathrynHalfForcesRemaining then
10208: LD_EXP 43
10212: NOT
10213: PUSH
10214: LD_EXP 44
10218: AND
10219: IFFALSE 10233
// AddMedal ( Commandement , 1 ) else
10221: LD_STRING Commandement
10223: PPUSH
10224: LD_INT 1
10226: PPUSH
10227: CALL_OW 101
10231: GO 10296
// if not KathrynLostControl and not KathrynHalfForcesRemaining then
10233: LD_EXP 43
10237: NOT
10238: PUSH
10239: LD_EXP 44
10243: NOT
10244: AND
10245: IFFALSE 10260
// AddMedal ( Commandement , - 1 ) else
10247: LD_STRING Commandement
10249: PPUSH
10250: LD_INT 1
10252: NEG
10253: PPUSH
10254: CALL_OW 101
10258: GO 10296
// if KathrynLostControl and KathrynHalfForcesRemaining then
10260: LD_EXP 43
10264: PUSH
10265: LD_EXP 44
10269: AND
10270: IFFALSE 10285
// AddMedal ( Commandement , - 2 ) else
10272: LD_STRING Commandement
10274: PPUSH
10275: LD_INT 2
10277: NEG
10278: PPUSH
10279: CALL_OW 101
10283: GO 10296
// AddMedal ( Commandement , - 3 ) ;
10285: LD_STRING Commandement
10287: PPUSH
10288: LD_INT 3
10290: NEG
10291: PPUSH
10292: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 15 then
10296: LD_INT 22
10298: PUSH
10299: LD_INT 7
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: LD_INT 21
10308: PUSH
10309: LD_INT 1
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL_OW 69
10324: PUSH
10325: LD_INT 15
10327: LESS
10328: IFFALSE 10343
// AddMedal ( Losses , - 1 ) else
10330: LD_STRING Losses
10332: PPUSH
10333: LD_INT 1
10335: NEG
10336: PPUSH
10337: CALL_OW 101
10341: GO 10353
// AddMedal ( Losses , 1 ) ;
10343: LD_STRING Losses
10345: PPUSH
10346: LD_INT 1
10348: PPUSH
10349: CALL_OW 101
// if not BradfordSecondCallout then
10353: LD_EXP 5
10357: NOT
10358: IFFALSE 10372
// AddMedal ( Hurry , 1 ) else
10360: LD_STRING Hurry
10362: PPUSH
10363: LD_INT 1
10365: PPUSH
10366: CALL_OW 101
10370: GO 10383
// AddMedal ( Hurry , - 1 ) ;
10372: LD_STRING Hurry
10374: PPUSH
10375: LD_INT 1
10377: NEG
10378: PPUSH
10379: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) ;
10383: LD_ADDR_VAR 0 3
10387: PUSH
10388: LD_INT 22
10390: PUSH
10391: LD_INT 7
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 21
10400: PUSH
10401: LD_INT 2
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: PPUSH
10412: CALL_OW 69
10416: ST_TO_ADDR
// for i = 1 to filter do
10417: LD_ADDR_VAR 0 4
10421: PUSH
10422: DOUBLE
10423: LD_INT 1
10425: DEC
10426: ST_TO_ADDR
10427: LD_VAR 0 3
10431: PUSH
10432: FOR_TO
10433: IFFALSE 10518
// begin Vehicles := Vehicles ^ [ GetChassis ( filter [ i ] ) , GetEngine ( filter [ i ] ) , GetControl ( filter [ i ] ) , GetWeapon ( filter [ i ] ) ] ;
10435: LD_ADDR_VAR 0 2
10439: PUSH
10440: LD_VAR 0 2
10444: PUSH
10445: LD_VAR 0 3
10449: PUSH
10450: LD_VAR 0 4
10454: ARRAY
10455: PPUSH
10456: CALL_OW 265
10460: PUSH
10461: LD_VAR 0 3
10465: PUSH
10466: LD_VAR 0 4
10470: ARRAY
10471: PPUSH
10472: CALL_OW 262
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_VAR 0 4
10486: ARRAY
10487: PPUSH
10488: CALL_OW 263
10492: PUSH
10493: LD_VAR 0 3
10497: PUSH
10498: LD_VAR 0 4
10502: ARRAY
10503: PPUSH
10504: CALL_OW 264
10508: PUSH
10509: EMPTY
10510: LIST
10511: LIST
10512: LIST
10513: LIST
10514: ADD
10515: ST_TO_ADDR
// end ;
10516: GO 10432
10518: POP
10519: POP
// SaveVariable ( Vehicles , AM04_Vehicles ) ;
10520: LD_VAR 0 2
10524: PPUSH
10525: LD_STRING AM04_Vehicles
10527: PPUSH
10528: CALL_OW 39
// SaveVariable ( BradfordSecondCallout , AM04_WasTooSlow ) ;
10532: LD_EXP 5
10536: PPUSH
10537: LD_STRING AM04_WasTooSlow
10539: PPUSH
10540: CALL_OW 39
// GiveMedals ( Main ) ;
10544: LD_STRING Main
10546: PPUSH
10547: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ) ;
10551: LD_INT 22
10553: PUSH
10554: LD_INT 7
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: PUSH
10561: LD_INT 21
10563: PUSH
10564: LD_INT 1
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 69
10579: PPUSH
10580: CALL_OW 43
// SaveCharacters ( Simone , Simone ) ;
10584: LD_EXP 6
10588: PPUSH
10589: LD_STRING Simone
10591: PPUSH
10592: CALL_OW 38
// SaveCharacters ( Miller , Miller ) ;
10596: LD_EXP 8
10600: PPUSH
10601: LD_STRING Miller
10603: PPUSH
10604: CALL_OW 38
// SaveCharacters ( Pravar , Pravar ) ;
10608: LD_EXP 9
10612: PPUSH
10613: LD_STRING Pravar
10615: PPUSH
10616: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) diff [ Simone , Miller , Pravar ] , AM04_Survivors ) ;
10620: LD_INT 22
10622: PUSH
10623: LD_INT 7
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PUSH
10630: LD_INT 21
10632: PUSH
10633: LD_INT 1
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PUSH
10649: LD_EXP 6
10653: PUSH
10654: LD_EXP 8
10658: PUSH
10659: LD_EXP 9
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: LIST
10668: DIFF
10669: PPUSH
10670: LD_STRING AM04_Survivors
10672: PPUSH
10673: CALL_OW 38
// YouWin ;
10677: CALL_OW 103
// exit ;
10681: GO 10683
// end ; end_of_file
10683: LD_VAR 0 1
10687: RET
// export ar_heavy_tracked , us_tesla_coil , ar_liquid_siberite , ar_heavy_gun , ar_mobile_mortar , ru_laser , ru_rocket_battery , ru_flame_thrower , Tech_Tesla ; export function InitiateConstants ; begin
10688: LD_INT 0
10690: PPUSH
// ar_heavy_tracked := 16 ;
10691: LD_ADDR_EXP 26
10695: PUSH
10696: LD_INT 16
10698: ST_TO_ADDR
// us_tesla_coil := 70 ;
10699: LD_ADDR_EXP 27
10703: PUSH
10704: LD_INT 70
10706: ST_TO_ADDR
// ar_liquid_siberite := 71 ;
10707: LD_ADDR_EXP 28
10711: PUSH
10712: LD_INT 71
10714: ST_TO_ADDR
// ar_heavy_gun := 72 ;
10715: LD_ADDR_EXP 29
10719: PUSH
10720: LD_INT 72
10722: ST_TO_ADDR
// ar_mobile_mortar := 73 ;
10723: LD_ADDR_EXP 30
10727: PUSH
10728: LD_INT 73
10730: ST_TO_ADDR
// ru_laser := 74 ;
10731: LD_ADDR_EXP 31
10735: PUSH
10736: LD_INT 74
10738: ST_TO_ADDR
// ru_rocket_battery := 75 ;
10739: LD_ADDR_EXP 32
10743: PUSH
10744: LD_INT 75
10746: ST_TO_ADDR
// ru_flame_thrower := 76 ;
10747: LD_ADDR_EXP 33
10751: PUSH
10752: LD_INT 76
10754: ST_TO_ADDR
// Tech_Tesla := 73 ;
10755: LD_ADDR_EXP 34
10759: PUSH
10760: LD_INT 73
10762: ST_TO_ADDR
// end ; end_of_file
10763: LD_VAR 0 1
10767: RET
// export RuSolMaxLevel ; export GeorgianAttacks ; export BradfordFirstThresholdTimer , BradfordSecondThresholdTimer , BradfordTerminatesMissionTimer ; export KathrynMoodIdleDropCoeficent ; export function PrepareDifficulty ; begin
10768: LD_INT 0
10770: PPUSH
// if difficulty = 1 then
10771: LD_OWVAR 67
10775: PUSH
10776: LD_INT 1
10778: EQUAL
10779: IFFALSE 10939
// begin RuSolMaxLevel := 7 ;
10781: LD_ADDR_EXP 35
10785: PUSH
10786: LD_INT 7
10788: ST_TO_ADDR
// SetTech ( tech_Tech1 , 3 , state_researched ) ;
10789: LD_INT 48
10791: PPUSH
10792: LD_INT 3
10794: PPUSH
10795: LD_INT 2
10797: PPUSH
10798: CALL_OW 322
// SetTech ( tech_Weap1 , 3 , state_researched ) ;
10802: LD_INT 51
10804: PPUSH
10805: LD_INT 3
10807: PPUSH
10808: LD_INT 2
10810: PPUSH
10811: CALL_OW 322
// SetTech ( tech_Comp1 , 3 , state_researched ) ;
10815: LD_INT 57
10817: PPUSH
10818: LD_INT 3
10820: PPUSH
10821: LD_INT 2
10823: PPUSH
10824: CALL_OW 322
// SetTech ( tech_Tech1 , 6 , state_researched ) ;
10828: LD_INT 48
10830: PPUSH
10831: LD_INT 6
10833: PPUSH
10834: LD_INT 2
10836: PPUSH
10837: CALL_OW 322
// SetTech ( tech_Weap1 , 6 , state_researched ) ;
10841: LD_INT 51
10843: PPUSH
10844: LD_INT 6
10846: PPUSH
10847: LD_INT 2
10849: PPUSH
10850: CALL_OW 322
// SetTech ( tech_Comp1 , 6 , state_researched ) ;
10854: LD_INT 57
10856: PPUSH
10857: LD_INT 6
10859: PPUSH
10860: LD_INT 2
10862: PPUSH
10863: CALL_OW 322
// SetTech ( tech_Tech1 , 8 , state_researched ) ;
10867: LD_INT 48
10869: PPUSH
10870: LD_INT 8
10872: PPUSH
10873: LD_INT 2
10875: PPUSH
10876: CALL_OW 322
// SetTech ( tech_Weap1 , 8 , state_researched ) ;
10880: LD_INT 51
10882: PPUSH
10883: LD_INT 8
10885: PPUSH
10886: LD_INT 2
10888: PPUSH
10889: CALL_OW 322
// GeorgianAttacks := 3 + ConvoysEscaped ;
10893: LD_ADDR_EXP 36
10897: PUSH
10898: LD_INT 3
10900: PUSH
10901: LD_EXP 23
10905: PLUS
10906: ST_TO_ADDR
// BradfordFirstThresholdTimer := 50 50$00 ;
10907: LD_ADDR_EXP 37
10911: PUSH
10912: LD_INT 105000
10914: ST_TO_ADDR
// BradfordSecondThresholdTimer := 70 70$00 ;
10915: LD_ADDR_EXP 38
10919: PUSH
10920: LD_INT 147000
10922: ST_TO_ADDR
// BradfordTerminatesMissionTimer := 80 80$00 ;
10923: LD_ADDR_EXP 39
10927: PUSH
10928: LD_INT 168000
10930: ST_TO_ADDR
// KathrynMoodIdleDropCoeficent := 3 ;
10931: LD_ADDR_EXP 40
10935: PUSH
10936: LD_INT 3
10938: ST_TO_ADDR
// end ; if difficulty = 2 then
10939: LD_OWVAR 67
10943: PUSH
10944: LD_INT 2
10946: EQUAL
10947: IFFALSE 11250
// begin RuSolMaxLevel := 8 ;
10949: LD_ADDR_EXP 35
10953: PUSH
10954: LD_INT 8
10956: ST_TO_ADDR
// SetTech ( tech_Tech1 , 3 , state_researched ) ;
10957: LD_INT 48
10959: PPUSH
10960: LD_INT 3
10962: PPUSH
10963: LD_INT 2
10965: PPUSH
10966: CALL_OW 322
// SetTech ( tech_Tech2 , 3 , state_researched ) ;
10970: LD_INT 49
10972: PPUSH
10973: LD_INT 3
10975: PPUSH
10976: LD_INT 2
10978: PPUSH
10979: CALL_OW 322
// SetTech ( tech_Weap1 , 3 , state_researched ) ;
10983: LD_INT 51
10985: PPUSH
10986: LD_INT 3
10988: PPUSH
10989: LD_INT 2
10991: PPUSH
10992: CALL_OW 322
// SetTech ( tech_Weap2 , 3 , state_researched ) ;
10996: LD_INT 52
10998: PPUSH
10999: LD_INT 3
11001: PPUSH
11002: LD_INT 2
11004: PPUSH
11005: CALL_OW 322
// SetTech ( tech_Comp1 , 3 , state_researched ) ;
11009: LD_INT 57
11011: PPUSH
11012: LD_INT 3
11014: PPUSH
11015: LD_INT 2
11017: PPUSH
11018: CALL_OW 322
// SetTech ( tech_Comp2 , 3 , state_researched ) ;
11022: LD_INT 58
11024: PPUSH
11025: LD_INT 3
11027: PPUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 322
// SetTech ( tech_ST1 , 3 , state_researched ) ;
11035: LD_INT 63
11037: PPUSH
11038: LD_INT 3
11040: PPUSH
11041: LD_INT 2
11043: PPUSH
11044: CALL_OW 322
// SetTech ( tech_Tech1 , 6 , state_researched ) ;
11048: LD_INT 48
11050: PPUSH
11051: LD_INT 6
11053: PPUSH
11054: LD_INT 2
11056: PPUSH
11057: CALL_OW 322
// SetTech ( tech_Tech2 , 6 , state_researched ) ;
11061: LD_INT 49
11063: PPUSH
11064: LD_INT 6
11066: PPUSH
11067: LD_INT 2
11069: PPUSH
11070: CALL_OW 322
// SetTech ( tech_Weap1 , 6 , state_researched ) ;
11074: LD_INT 51
11076: PPUSH
11077: LD_INT 6
11079: PPUSH
11080: LD_INT 2
11082: PPUSH
11083: CALL_OW 322
// SetTech ( tech_Weap2 , 6 , state_researched ) ;
11087: LD_INT 52
11089: PPUSH
11090: LD_INT 6
11092: PPUSH
11093: LD_INT 2
11095: PPUSH
11096: CALL_OW 322
// SetTech ( tech_Comp1 , 6 , state_researched ) ;
11100: LD_INT 57
11102: PPUSH
11103: LD_INT 6
11105: PPUSH
11106: LD_INT 2
11108: PPUSH
11109: CALL_OW 322
// SetTech ( tech_Comp2 , 6 , state_researched ) ;
11113: LD_INT 58
11115: PPUSH
11116: LD_INT 6
11118: PPUSH
11119: LD_INT 2
11121: PPUSH
11122: CALL_OW 322
// SetTech ( tech_ST1 , 6 , state_researched ) ;
11126: LD_INT 63
11128: PPUSH
11129: LD_INT 6
11131: PPUSH
11132: LD_INT 2
11134: PPUSH
11135: CALL_OW 322
// SetTech ( tech_Tech1 , 8 , state_researched ) ;
11139: LD_INT 48
11141: PPUSH
11142: LD_INT 8
11144: PPUSH
11145: LD_INT 2
11147: PPUSH
11148: CALL_OW 322
// SetTech ( tech_Tech2 , 8 , state_researched ) ;
11152: LD_INT 49
11154: PPUSH
11155: LD_INT 8
11157: PPUSH
11158: LD_INT 2
11160: PPUSH
11161: CALL_OW 322
// SetTech ( tech_Weap1 , 8 , state_researched ) ;
11165: LD_INT 51
11167: PPUSH
11168: LD_INT 8
11170: PPUSH
11171: LD_INT 2
11173: PPUSH
11174: CALL_OW 322
// SetTech ( tech_Weap2 , 8 , state_researched ) ;
11178: LD_INT 52
11180: PPUSH
11181: LD_INT 8
11183: PPUSH
11184: LD_INT 2
11186: PPUSH
11187: CALL_OW 322
// SetTech ( tech_StimDrugs , 8 , state_researched ) ;
11191: LD_INT 5
11193: PPUSH
11194: LD_INT 8
11196: PPUSH
11197: LD_INT 2
11199: PPUSH
11200: CALL_OW 322
// GeorgianAttacks := 4 + ConvoysEscaped ;
11204: LD_ADDR_EXP 36
11208: PUSH
11209: LD_INT 4
11211: PUSH
11212: LD_EXP 23
11216: PLUS
11217: ST_TO_ADDR
// BradfordFirstThresholdTimer := 40 40$00 ;
11218: LD_ADDR_EXP 37
11222: PUSH
11223: LD_INT 84000
11225: ST_TO_ADDR
// BradfordSecondThresholdTimer := 60 60$00 ;
11226: LD_ADDR_EXP 38
11230: PUSH
11231: LD_INT 126000
11233: ST_TO_ADDR
// BradfordTerminatesMissionTimer := 70 70$00 ;
11234: LD_ADDR_EXP 39
11238: PUSH
11239: LD_INT 147000
11241: ST_TO_ADDR
// KathrynMoodIdleDropCoeficent := 5 ;
11242: LD_ADDR_EXP 40
11246: PUSH
11247: LD_INT 5
11249: ST_TO_ADDR
// end ; if difficulty = 3 then
11250: LD_OWVAR 67
11254: PUSH
11255: LD_INT 3
11257: EQUAL
11258: IFFALSE 11652
// begin RuSolMaxLevel := 9 ;
11260: LD_ADDR_EXP 35
11264: PUSH
11265: LD_INT 9
11267: ST_TO_ADDR
// SetTech ( tech_Tech1 , 3 , state_researched ) ;
11268: LD_INT 48
11270: PPUSH
11271: LD_INT 3
11273: PPUSH
11274: LD_INT 2
11276: PPUSH
11277: CALL_OW 322
// SetTech ( tech_Weap1 , 3 , state_researched ) ;
11281: LD_INT 51
11283: PPUSH
11284: LD_INT 3
11286: PPUSH
11287: LD_INT 2
11289: PPUSH
11290: CALL_OW 322
// SetTech ( tech_Comp1 , 3 , state_researched ) ;
11294: LD_INT 57
11296: PPUSH
11297: LD_INT 3
11299: PPUSH
11300: LD_INT 2
11302: PPUSH
11303: CALL_OW 322
// SetTech ( tech_Tech2 , 3 , state_researched ) ;
11307: LD_INT 49
11309: PPUSH
11310: LD_INT 3
11312: PPUSH
11313: LD_INT 2
11315: PPUSH
11316: CALL_OW 322
// SetTech ( tech_Weap2 , 3 , state_researched ) ;
11320: LD_INT 52
11322: PPUSH
11323: LD_INT 3
11325: PPUSH
11326: LD_INT 2
11328: PPUSH
11329: CALL_OW 322
// SetTech ( tech_Comp2 , 3 , state_researched ) ;
11333: LD_INT 58
11335: PPUSH
11336: LD_INT 3
11338: PPUSH
11339: LD_INT 2
11341: PPUSH
11342: CALL_OW 322
// SetTech ( tech_Tech3 , 3 , state_researched ) ;
11346: LD_INT 50
11348: PPUSH
11349: LD_INT 3
11351: PPUSH
11352: LD_INT 2
11354: PPUSH
11355: CALL_OW 322
// SetTech ( tech_Comp3 , 3 , state_researched ) ;
11359: LD_INT 59
11361: PPUSH
11362: LD_INT 3
11364: PPUSH
11365: LD_INT 2
11367: PPUSH
11368: CALL_OW 322
// SetTech ( tech_Weap3 , 3 , state_researched ) ;
11372: LD_INT 53
11374: PPUSH
11375: LD_INT 3
11377: PPUSH
11378: LD_INT 2
11380: PPUSH
11381: CALL_OW 322
// SetTech ( tech_ST1 , 3 , state_researched ) ;
11385: LD_INT 63
11387: PPUSH
11388: LD_INT 3
11390: PPUSH
11391: LD_INT 2
11393: PPUSH
11394: CALL_OW 322
// SetTech ( tech_ST2 , 3 , state_researched ) ;
11398: LD_INT 64
11400: PPUSH
11401: LD_INT 3
11403: PPUSH
11404: LD_INT 2
11406: PPUSH
11407: CALL_OW 322
// SetTech ( tech_Tech1 , 6 , state_researched ) ;
11411: LD_INT 48
11413: PPUSH
11414: LD_INT 6
11416: PPUSH
11417: LD_INT 2
11419: PPUSH
11420: CALL_OW 322
// SetTech ( tech_Weap1 , 6 , state_researched ) ;
11424: LD_INT 51
11426: PPUSH
11427: LD_INT 6
11429: PPUSH
11430: LD_INT 2
11432: PPUSH
11433: CALL_OW 322
// SetTech ( tech_Comp1 , 6 , state_researched ) ;
11437: LD_INT 57
11439: PPUSH
11440: LD_INT 6
11442: PPUSH
11443: LD_INT 2
11445: PPUSH
11446: CALL_OW 322
// SetTech ( tech_Tech2 , 6 , state_researched ) ;
11450: LD_INT 49
11452: PPUSH
11453: LD_INT 6
11455: PPUSH
11456: LD_INT 2
11458: PPUSH
11459: CALL_OW 322
// SetTech ( tech_Weap2 , 6 , state_researched ) ;
11463: LD_INT 52
11465: PPUSH
11466: LD_INT 6
11468: PPUSH
11469: LD_INT 2
11471: PPUSH
11472: CALL_OW 322
// SetTech ( tech_Comp2 , 6 , state_researched ) ;
11476: LD_INT 58
11478: PPUSH
11479: LD_INT 6
11481: PPUSH
11482: LD_INT 2
11484: PPUSH
11485: CALL_OW 322
// SetTech ( tech_ST1 , 6 , state_researched ) ;
11489: LD_INT 63
11491: PPUSH
11492: LD_INT 6
11494: PPUSH
11495: LD_INT 2
11497: PPUSH
11498: CALL_OW 322
// SetTech ( tech_ST2 , 6 , state_researched ) ;
11502: LD_INT 64
11504: PPUSH
11505: LD_INT 6
11507: PPUSH
11508: LD_INT 2
11510: PPUSH
11511: CALL_OW 322
// SetTech ( tech_Tech1 , 8 , state_researched ) ;
11515: LD_INT 48
11517: PPUSH
11518: LD_INT 8
11520: PPUSH
11521: LD_INT 2
11523: PPUSH
11524: CALL_OW 322
// SetTech ( tech_Tech2 , 8 , state_researched ) ;
11528: LD_INT 49
11530: PPUSH
11531: LD_INT 8
11533: PPUSH
11534: LD_INT 2
11536: PPUSH
11537: CALL_OW 322
// SetTech ( tech_Tech3 , 8 , state_researched ) ;
11541: LD_INT 50
11543: PPUSH
11544: LD_INT 8
11546: PPUSH
11547: LD_INT 2
11549: PPUSH
11550: CALL_OW 322
// SetTech ( tech_Weap1 , 8 , state_researched ) ;
11554: LD_INT 51
11556: PPUSH
11557: LD_INT 8
11559: PPUSH
11560: LD_INT 2
11562: PPUSH
11563: CALL_OW 322
// SetTech ( tech_Weap2 , 8 , state_researched ) ;
11567: LD_INT 52
11569: PPUSH
11570: LD_INT 8
11572: PPUSH
11573: LD_INT 2
11575: PPUSH
11576: CALL_OW 322
// SetTech ( tech_Weap3 , 8 , state_researched ) ;
11580: LD_INT 53
11582: PPUSH
11583: LD_INT 8
11585: PPUSH
11586: LD_INT 2
11588: PPUSH
11589: CALL_OW 322
// SetTech ( tech_StimDrugs , 8 , state_researched ) ;
11593: LD_INT 5
11595: PPUSH
11596: LD_INT 8
11598: PPUSH
11599: LD_INT 2
11601: PPUSH
11602: CALL_OW 322
// GeorgianAttacks := 5 + ConvoysEscaped ;
11606: LD_ADDR_EXP 36
11610: PUSH
11611: LD_INT 5
11613: PUSH
11614: LD_EXP 23
11618: PLUS
11619: ST_TO_ADDR
// BradfordFirstThresholdTimer := 25 25$00 ;
11620: LD_ADDR_EXP 37
11624: PUSH
11625: LD_INT 52500
11627: ST_TO_ADDR
// BradfordSecondThresholdTimer := 50 50$00 ;
11628: LD_ADDR_EXP 38
11632: PUSH
11633: LD_INT 105000
11635: ST_TO_ADDR
// BradfordTerminatesMissionTimer := 60 60$00 ;
11636: LD_ADDR_EXP 39
11640: PUSH
11641: LD_INT 126000
11643: ST_TO_ADDR
// KathrynMoodIdleDropCoeficent := 10 ;
11644: LD_ADDR_EXP 40
11648: PUSH
11649: LD_INT 10
11651: ST_TO_ADDR
// end ; end ; end_of_file
11652: LD_VAR 0 1
11656: RET
// export KathrynOrderAttack ; export KathrynAttackStance ; export KathrynLostControl ; export KathrynHalfForcesRemaining ; export KathrynMood ; export KathrynStatus ; export attack_group ; export function KathrynScript ; var i , xy , sold , e , mech , sci , driver , hurt , highHurt , tmp , vehs , parking , target , soldAttackArea ; begin
11657: LD_INT 0
11659: PPUSH
11660: PPUSH
11661: PPUSH
11662: PPUSH
11663: PPUSH
11664: PPUSH
11665: PPUSH
11666: PPUSH
11667: PPUSH
11668: PPUSH
11669: PPUSH
11670: PPUSH
11671: PPUSH
11672: PPUSH
11673: PPUSH
// sold := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 1 ] ] ) ;
11674: LD_ADDR_VAR 0 4
11678: PUSH
11679: LD_INT 22
11681: PUSH
11682: LD_INT 4
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PUSH
11689: LD_INT 25
11691: PUSH
11692: LD_INT 1
11694: PUSH
11695: EMPTY
11696: LIST
11697: LIST
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: PPUSH
11703: CALL_OW 69
11707: ST_TO_ADDR
// mech := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
11708: LD_ADDR_VAR 0 6
11712: PUSH
11713: LD_INT 22
11715: PUSH
11716: LD_INT 4
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: LD_INT 25
11725: PUSH
11726: LD_INT 3
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PPUSH
11737: CALL_OW 69
11741: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
11742: LD_ADDR_VAR 0 7
11746: PUSH
11747: LD_INT 22
11749: PUSH
11750: LD_INT 4
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 25
11759: PUSH
11760: LD_INT 4
11762: PUSH
11763: EMPTY
11764: LIST
11765: LIST
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PPUSH
11771: CALL_OW 69
11775: ST_TO_ADDR
// vehs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) ;
11776: LD_ADDR_VAR 0 12
11780: PUSH
11781: LD_INT 22
11783: PUSH
11784: LD_INT 4
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 21
11793: PUSH
11794: LD_INT 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PPUSH
11805: CALL_OW 69
11809: ST_TO_ADDR
// while not ReachedBase do
11810: LD_EXP 3
11814: NOT
11815: IFFALSE 14639
// begin wait ( 0 0$1 ) ;
11817: LD_INT 35
11819: PPUSH
11820: CALL_OW 67
// debug_strings := tick ;
11824: LD_ADDR_OWVAR 48
11828: PUSH
11829: LD_OWVAR 1
11833: ST_TO_ADDR
// if not KathrynStatus then
11834: LD_EXP 46
11838: NOT
11839: IFFALSE 11843
// continue ;
11841: GO 11810
// case KathrynStatus of 1 :
11843: LD_EXP 46
11847: PUSH
11848: LD_INT 1
11850: DOUBLE
11851: EQUAL
11852: IFTRUE 11856
11854: GO 11898
11856: POP
// begin parking := KatParking1 ;
11857: LD_ADDR_VAR 0 13
11861: PUSH
11862: LD_INT 10
11864: ST_TO_ADDR
// target := KatBase1 ;
11865: LD_ADDR_VAR 0 14
11869: PUSH
11870: LD_INT 14
11872: ST_TO_ADDR
// soldAttackArea := KatSold1 ;
11873: LD_ADDR_VAR 0 15
11877: PUSH
11878: LD_INT 19
11880: ST_TO_ADDR
// xy := [ 238 , 278 ] ;
11881: LD_ADDR_VAR 0 3
11885: PUSH
11886: LD_INT 238
11888: PUSH
11889: LD_INT 278
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: ST_TO_ADDR
// end ; 2 :
11896: GO 11999
11898: LD_INT 2
11900: DOUBLE
11901: EQUAL
11902: IFTRUE 11906
11904: GO 11948
11906: POP
// begin parking := KatParking2 ;
11907: LD_ADDR_VAR 0 13
11911: PUSH
11912: LD_INT 17
11914: ST_TO_ADDR
// target := KatBase2 ;
11915: LD_ADDR_VAR 0 14
11919: PUSH
11920: LD_INT 15
11922: ST_TO_ADDR
// soldAttackArea := KatSold2 ;
11923: LD_ADDR_VAR 0 15
11927: PUSH
11928: LD_INT 20
11930: ST_TO_ADDR
// xy := [ 208 , 211 ] ;
11931: LD_ADDR_VAR 0 3
11935: PUSH
11936: LD_INT 208
11938: PUSH
11939: LD_INT 211
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: ST_TO_ADDR
// end ; 3 :
11946: GO 11999
11948: LD_INT 3
11950: DOUBLE
11951: EQUAL
11952: IFTRUE 11956
11954: GO 11998
11956: POP
// begin parking := KatParking3 ;
11957: LD_ADDR_VAR 0 13
11961: PUSH
11962: LD_INT 18
11964: ST_TO_ADDR
// target := KatBase3 ;
11965: LD_ADDR_VAR 0 14
11969: PUSH
11970: LD_INT 16
11972: ST_TO_ADDR
// soldAttackArea := KatSold3 ;
11973: LD_ADDR_VAR 0 15
11977: PUSH
11978: LD_INT 21
11980: ST_TO_ADDR
// xy := [ 174 , 156 ] ;
11981: LD_ADDR_VAR 0 3
11985: PUSH
11986: LD_INT 174
11988: PUSH
11989: LD_INT 156
11991: PUSH
11992: EMPTY
11993: LIST
11994: LIST
11995: ST_TO_ADDR
// end ; end ;
11996: GO 11999
11998: POP
// if not KathrynOrderAttack then
11999: LD_EXP 41
12003: NOT
12004: IFFALSE 12566
// begin if vehs then
12006: LD_VAR 0 12
12010: IFFALSE 12145
// for i in vehs do
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_VAR 0 12
12021: PUSH
12022: FOR_IN
12023: IFFALSE 12143
// begin if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 15 then
12025: LD_VAR 0 2
12029: PPUSH
12030: LD_VAR 0 3
12034: PUSH
12035: LD_INT 1
12037: ARRAY
12038: PPUSH
12039: LD_VAR 0 3
12043: PUSH
12044: LD_INT 2
12046: ARRAY
12047: PPUSH
12048: CALL_OW 297
12052: PUSH
12053: LD_INT 15
12055: GREATER
12056: IFFALSE 12074
// ComMoveToArea ( i , parking ) else
12058: LD_VAR 0 2
12062: PPUSH
12063: LD_VAR 0 13
12067: PPUSH
12068: CALL_OW 113
12072: GO 12141
// if GetLives ( i ) < 1000 then
12074: LD_VAR 0 2
12078: PPUSH
12079: CALL_OW 256
12083: PUSH
12084: LD_INT 1000
12086: LESS
12087: IFFALSE 12141
// begin driver := IsDrivenBy ( i ) ;
12089: LD_ADDR_VAR 0 8
12093: PUSH
12094: LD_VAR 0 2
12098: PPUSH
12099: CALL_OW 311
12103: ST_TO_ADDR
// ComExitVehicle ( driver ) ;
12104: LD_VAR 0 8
12108: PPUSH
12109: CALL_OW 121
// AddComRepairVehicle ( driver , i ) ;
12113: LD_VAR 0 8
12117: PPUSH
12118: LD_VAR 0 2
12122: PPUSH
12123: CALL_OW 189
// AddComEnterUnit ( driver , i ) ;
12127: LD_VAR 0 8
12131: PPUSH
12132: LD_VAR 0 2
12136: PPUSH
12137: CALL_OW 180
// end ; end ;
12141: GO 12022
12143: POP
12144: POP
// if sold then
12145: LD_VAR 0 4
12149: IFFALSE 12242
// for i in sold do
12151: LD_ADDR_VAR 0 2
12155: PUSH
12156: LD_VAR 0 4
12160: PUSH
12161: FOR_IN
12162: IFFALSE 12240
// begin if GetTag ( i ) = 5 then
12164: LD_VAR 0 2
12168: PPUSH
12169: CALL_OW 110
12173: PUSH
12174: LD_INT 5
12176: EQUAL
12177: IFFALSE 12191
// SetTag ( i , 0 ) ;
12179: LD_VAR 0 2
12183: PPUSH
12184: LD_INT 0
12186: PPUSH
12187: CALL_OW 109
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 15 then
12191: LD_VAR 0 2
12195: PPUSH
12196: LD_VAR 0 3
12200: PUSH
12201: LD_INT 1
12203: ARRAY
12204: PPUSH
12205: LD_VAR 0 3
12209: PUSH
12210: LD_INT 2
12212: ARRAY
12213: PPUSH
12214: CALL_OW 297
12218: PUSH
12219: LD_INT 15
12221: GREATER
12222: IFFALSE 12238
// ComMoveToArea ( i , parking ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_VAR 0 13
12233: PPUSH
12234: CALL_OW 113
// end ;
12238: GO 12161
12240: POP
12241: POP
// if mech then
12242: LD_VAR 0 6
12246: IFFALSE 12410
// for i in mech do
12248: LD_ADDR_VAR 0 2
12252: PUSH
12253: LD_VAR 0 6
12257: PUSH
12258: FOR_IN
12259: IFFALSE 12408
// begin e := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_empty ] , [ f_lives , 1000 ] ] ) ;
12261: LD_ADDR_VAR 0 5
12265: PUSH
12266: LD_INT 22
12268: PUSH
12269: LD_INT 4
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 2
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 58
12288: PUSH
12289: EMPTY
12290: LIST
12291: PUSH
12292: LD_INT 24
12294: PUSH
12295: LD_INT 1000
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: PPUSH
12308: CALL_OW 69
12312: ST_TO_ADDR
// if not IsInUnit ( i ) and not HasTask ( i ) then
12313: LD_VAR 0 2
12317: PPUSH
12318: CALL_OW 310
12322: NOT
12323: PUSH
12324: LD_VAR 0 2
12328: PPUSH
12329: CALL_OW 314
12333: NOT
12334: AND
12335: IFFALSE 12406
// if e then
12337: LD_VAR 0 5
12341: IFFALSE 12359
// ComEnterUnit ( i , e ) else
12343: LD_VAR 0 2
12347: PPUSH
12348: LD_VAR 0 5
12352: PPUSH
12353: CALL_OW 120
12357: GO 12406
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 15 then
12359: LD_VAR 0 2
12363: PPUSH
12364: LD_VAR 0 3
12368: PUSH
12369: LD_INT 1
12371: ARRAY
12372: PPUSH
12373: LD_VAR 0 3
12377: PUSH
12378: LD_INT 2
12380: ARRAY
12381: PPUSH
12382: CALL_OW 297
12386: PUSH
12387: LD_INT 15
12389: GREATER
12390: IFFALSE 12406
// ComMoveToArea ( i , parking ) ;
12392: LD_VAR 0 2
12396: PPUSH
12397: LD_VAR 0 13
12401: PPUSH
12402: CALL_OW 113
// end ;
12406: GO 12258
12408: POP
12409: POP
// if sci then
12410: LD_VAR 0 7
12414: IFFALSE 12564
// begin hurt := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
12416: LD_ADDR_VAR 0 9
12420: PUSH
12421: LD_INT 22
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: PUSH
12431: LD_INT 21
12433: PUSH
12434: LD_INT 1
12436: PUSH
12437: EMPTY
12438: LIST
12439: LIST
12440: PUSH
12441: LD_INT 3
12443: PUSH
12444: LD_INT 24
12446: PUSH
12447: LD_INT 750
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL_OW 69
12467: ST_TO_ADDR
// for i in sci do
12468: LD_ADDR_VAR 0 2
12472: PUSH
12473: LD_VAR 0 7
12477: PUSH
12478: FOR_IN
12479: IFFALSE 12562
// begin if hurt then
12481: LD_VAR 0 9
12485: IFFALSE 12513
// ComHeal ( i , NearestUnitToUnit ( hurt , i ) ) else
12487: LD_VAR 0 2
12491: PPUSH
12492: LD_VAR 0 9
12496: PPUSH
12497: LD_VAR 0 2
12501: PPUSH
12502: CALL_OW 74
12506: PPUSH
12507: CALL_OW 128
12511: GO 12560
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 15 then
12513: LD_VAR 0 2
12517: PPUSH
12518: LD_VAR 0 3
12522: PUSH
12523: LD_INT 1
12525: ARRAY
12526: PPUSH
12527: LD_VAR 0 3
12531: PUSH
12532: LD_INT 2
12534: ARRAY
12535: PPUSH
12536: CALL_OW 297
12540: PUSH
12541: LD_INT 15
12543: GREATER
12544: IFFALSE 12560
// ComMoveToArea ( i , parking ) ;
12546: LD_VAR 0 2
12550: PPUSH
12551: LD_VAR 0 13
12555: PPUSH
12556: CALL_OW 113
// end ;
12560: GO 12478
12562: POP
12563: POP
// end ; end else
12564: GO 14637
// begin tmp := FilterUnitsInArea ( target , [ f_enemy , 4 ] ) ;
12566: LD_ADDR_VAR 0 11
12570: PUSH
12571: LD_VAR 0 14
12575: PPUSH
12576: LD_INT 81
12578: PUSH
12579: LD_INT 4
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PPUSH
12586: CALL_OW 70
12590: ST_TO_ADDR
// if not tmp then
12591: LD_VAR 0 11
12595: NOT
12596: IFFALSE 12622
// begin KathrynStatus := KathrynStatus + 1 ;
12598: LD_ADDR_EXP 46
12602: PUSH
12603: LD_EXP 46
12607: PUSH
12608: LD_INT 1
12610: PLUS
12611: ST_TO_ADDR
// KathrynOrderAttack := false ;
12612: LD_ADDR_EXP 41
12616: PUSH
12617: LD_INT 0
12619: ST_TO_ADDR
// continue ;
12620: GO 11810
// end ; if KathrynAttackStance = 1 then
12622: LD_EXP 42
12626: PUSH
12627: LD_INT 1
12629: EQUAL
12630: IFFALSE 13273
// begin for i in vehs do
12632: LD_ADDR_VAR 0 2
12636: PUSH
12637: LD_VAR 0 12
12641: PUSH
12642: FOR_IN
12643: IFFALSE 12897
// begin driver := IsDrivenBy ( i ) ;
12645: LD_ADDR_VAR 0 8
12649: PUSH
12650: LD_VAR 0 2
12654: PPUSH
12655: CALL_OW 311
12659: ST_TO_ADDR
// if not driver then
12660: LD_VAR 0 8
12664: NOT
12665: IFFALSE 12669
// continue ;
12667: GO 12642
// if GetLives ( i ) < 350 then
12669: LD_VAR 0 2
12673: PPUSH
12674: CALL_OW 256
12678: PUSH
12679: LD_INT 350
12681: LESS
12682: IFFALSE 12696
// SetTag ( i , 2 ) ;
12684: LD_VAR 0 2
12688: PPUSH
12689: LD_INT 2
12691: PPUSH
12692: CALL_OW 109
// if GetLives ( i ) < 1000 and GetTag ( i ) = 2 then
12696: LD_VAR 0 2
12700: PPUSH
12701: CALL_OW 256
12705: PUSH
12706: LD_INT 1000
12708: LESS
12709: PUSH
12710: LD_VAR 0 2
12714: PPUSH
12715: CALL_OW 110
12719: PUSH
12720: LD_INT 2
12722: EQUAL
12723: AND
12724: IFFALSE 12802
// begin if not IsInArea ( i , parking ) then
12726: LD_VAR 0 2
12730: PPUSH
12731: LD_VAR 0 13
12735: PPUSH
12736: CALL_OW 308
12740: NOT
12741: IFFALSE 12759
// ComMoveToArea ( i , parking ) else
12743: LD_VAR 0 2
12747: PPUSH
12748: LD_VAR 0 13
12752: PPUSH
12753: CALL_OW 113
12757: GO 12802
// if driver then
12759: LD_VAR 0 8
12763: IFFALSE 12802
// begin ComExitVehicle ( driver ) ;
12765: LD_VAR 0 8
12769: PPUSH
12770: CALL_OW 121
// AddComRepairVehicle ( driver , i ) ;
12774: LD_VAR 0 8
12778: PPUSH
12779: LD_VAR 0 2
12783: PPUSH
12784: CALL_OW 189
// AddComEnterUnit ( driver , i ) ;
12788: LD_VAR 0 8
12792: PPUSH
12793: LD_VAR 0 2
12797: PPUSH
12798: CALL_OW 180
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 2 then
12802: LD_VAR 0 2
12806: PPUSH
12807: CALL_OW 256
12811: PUSH
12812: LD_INT 1000
12814: EQUAL
12815: PUSH
12816: LD_VAR 0 2
12820: PPUSH
12821: CALL_OW 110
12825: PUSH
12826: LD_INT 2
12828: EQUAL
12829: AND
12830: IFFALSE 12844
// SetTag ( i , 0 ) ;
12832: LD_VAR 0 2
12836: PPUSH
12837: LD_INT 0
12839: PPUSH
12840: CALL_OW 109
// if not HasTask ( driver ) and GetTag ( i ) <> 2 then
12844: LD_VAR 0 8
12848: PPUSH
12849: CALL_OW 314
12853: NOT
12854: PUSH
12855: LD_VAR 0 2
12859: PPUSH
12860: CALL_OW 110
12864: PUSH
12865: LD_INT 2
12867: NONEQUAL
12868: AND
12869: IFFALSE 12895
// ComAttackUnit ( i , NearestUnitToUnit ( tmp , i ) ) ;
12871: LD_VAR 0 2
12875: PPUSH
12876: LD_VAR 0 11
12880: PPUSH
12881: LD_VAR 0 2
12885: PPUSH
12886: CALL_OW 74
12890: PPUSH
12891: CALL_OW 115
// end ;
12895: GO 12642
12897: POP
12898: POP
// for i in sold do
12899: LD_ADDR_VAR 0 2
12903: PUSH
12904: LD_VAR 0 4
12908: PUSH
12909: FOR_IN
12910: IFFALSE 13068
// begin if GetLives ( i ) < 350 then
12912: LD_VAR 0 2
12916: PPUSH
12917: CALL_OW 256
12921: PUSH
12922: LD_INT 350
12924: LESS
12925: IFFALSE 12939
// SetTag ( i , 3 ) ;
12927: LD_VAR 0 2
12931: PPUSH
12932: LD_INT 3
12934: PPUSH
12935: CALL_OW 109
// if GetTag ( i ) = 3 and not IsInArea ( i , parking ) then
12939: LD_VAR 0 2
12943: PPUSH
12944: CALL_OW 110
12948: PUSH
12949: LD_INT 3
12951: EQUAL
12952: PUSH
12953: LD_VAR 0 2
12957: PPUSH
12958: LD_VAR 0 13
12962: PPUSH
12963: CALL_OW 308
12967: NOT
12968: AND
12969: IFFALSE 12985
// ComMoveToArea ( i , parking ) ;
12971: LD_VAR 0 2
12975: PPUSH
12976: LD_VAR 0 13
12980: PPUSH
12981: CALL_OW 113
// if GetLives ( i ) = 1000 and GetTag ( i ) = 3 then
12985: LD_VAR 0 2
12989: PPUSH
12990: CALL_OW 256
12994: PUSH
12995: LD_INT 1000
12997: EQUAL
12998: PUSH
12999: LD_VAR 0 2
13003: PPUSH
13004: CALL_OW 110
13008: PUSH
13009: LD_INT 3
13011: EQUAL
13012: AND
13013: IFFALSE 13027
// SetTag ( i , 0 ) ;
13015: LD_VAR 0 2
13019: PPUSH
13020: LD_INT 0
13022: PPUSH
13023: CALL_OW 109
// if GetTag ( i ) <> 3 then
13027: LD_VAR 0 2
13031: PPUSH
13032: CALL_OW 110
13036: PUSH
13037: LD_INT 3
13039: NONEQUAL
13040: IFFALSE 13066
// ComAttackUnit ( i , NearestUnitToUnit ( tmp , i ) ) ;
13042: LD_VAR 0 2
13046: PPUSH
13047: LD_VAR 0 11
13051: PPUSH
13052: LD_VAR 0 2
13056: PPUSH
13057: CALL_OW 74
13061: PPUSH
13062: CALL_OW 115
// end ;
13066: GO 12909
13068: POP
13069: POP
// hurt := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
13070: LD_ADDR_VAR 0 9
13074: PUSH
13075: LD_INT 22
13077: PUSH
13078: LD_INT 4
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 21
13087: PUSH
13088: LD_INT 1
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 24
13100: PUSH
13101: LD_INT 750
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: PPUSH
13117: CALL_OW 69
13121: ST_TO_ADDR
// for i in sci do
13122: LD_ADDR_VAR 0 2
13126: PUSH
13127: LD_VAR 0 7
13131: PUSH
13132: FOR_IN
13133: IFFALSE 13269
// begin if not hurt and sold and GetDistUnits ( i , NearestUnitToUnit ( sold , i ) ) > 7 then
13135: LD_VAR 0 9
13139: NOT
13140: PUSH
13141: LD_VAR 0 4
13145: AND
13146: PUSH
13147: LD_VAR 0 2
13151: PPUSH
13152: LD_VAR 0 4
13156: PPUSH
13157: LD_VAR 0 2
13161: PPUSH
13162: CALL_OW 74
13166: PPUSH
13167: CALL_OW 296
13171: PUSH
13172: LD_INT 7
13174: GREATER
13175: AND
13176: IFFALSE 13204
// ComMoveUnit ( i , NearestUnitToUnit ( sold , i ) ) else
13178: LD_VAR 0 2
13182: PPUSH
13183: LD_VAR 0 4
13187: PPUSH
13188: LD_VAR 0 2
13192: PPUSH
13193: CALL_OW 74
13197: PPUSH
13198: CALL_OW 112
13202: GO 13267
// if hurt then
13204: LD_VAR 0 9
13208: IFFALSE 13236
// ComHeal ( i , NearestUnitToUnit ( hurt , i ) ) else
13210: LD_VAR 0 2
13214: PPUSH
13215: LD_VAR 0 9
13219: PPUSH
13220: LD_VAR 0 2
13224: PPUSH
13225: CALL_OW 74
13229: PPUSH
13230: CALL_OW 128
13234: GO 13267
// if not IsInArea ( i , parking ) then
13236: LD_VAR 0 2
13240: PPUSH
13241: LD_VAR 0 13
13245: PPUSH
13246: CALL_OW 308
13250: NOT
13251: IFFALSE 13267
// ComMoveToArea ( i , parking ) ;
13253: LD_VAR 0 2
13257: PPUSH
13258: LD_VAR 0 13
13262: PPUSH
13263: CALL_OW 113
// end ;
13267: GO 13132
13269: POP
13270: POP
// end else
13271: GO 14637
// if KathrynAttackStance = 2 then
13273: LD_EXP 42
13277: PUSH
13278: LD_INT 2
13280: EQUAL
13281: IFFALSE 14071
// begin for i in vehs do
13283: LD_ADDR_VAR 0 2
13287: PUSH
13288: LD_VAR 0 12
13292: PUSH
13293: FOR_IN
13294: IFFALSE 13548
// begin driver := IsDrivenBy ( i ) ;
13296: LD_ADDR_VAR 0 8
13300: PUSH
13301: LD_VAR 0 2
13305: PPUSH
13306: CALL_OW 311
13310: ST_TO_ADDR
// if not driver then
13311: LD_VAR 0 8
13315: NOT
13316: IFFALSE 13320
// continue ;
13318: GO 13293
// if GetLives ( i ) < 550 then
13320: LD_VAR 0 2
13324: PPUSH
13325: CALL_OW 256
13329: PUSH
13330: LD_INT 550
13332: LESS
13333: IFFALSE 13347
// SetTag ( i , 2 ) ;
13335: LD_VAR 0 2
13339: PPUSH
13340: LD_INT 2
13342: PPUSH
13343: CALL_OW 109
// if GetLives ( i ) < 1000 and GetTag ( i ) = 2 then
13347: LD_VAR 0 2
13351: PPUSH
13352: CALL_OW 256
13356: PUSH
13357: LD_INT 1000
13359: LESS
13360: PUSH
13361: LD_VAR 0 2
13365: PPUSH
13366: CALL_OW 110
13370: PUSH
13371: LD_INT 2
13373: EQUAL
13374: AND
13375: IFFALSE 13453
// begin if not IsInArea ( i , parking ) then
13377: LD_VAR 0 2
13381: PPUSH
13382: LD_VAR 0 13
13386: PPUSH
13387: CALL_OW 308
13391: NOT
13392: IFFALSE 13410
// ComMoveToArea ( i , parking ) else
13394: LD_VAR 0 2
13398: PPUSH
13399: LD_VAR 0 13
13403: PPUSH
13404: CALL_OW 113
13408: GO 13453
// if driver then
13410: LD_VAR 0 8
13414: IFFALSE 13453
// begin ComExitVehicle ( driver ) ;
13416: LD_VAR 0 8
13420: PPUSH
13421: CALL_OW 121
// AddComRepairVehicle ( driver , i ) ;
13425: LD_VAR 0 8
13429: PPUSH
13430: LD_VAR 0 2
13434: PPUSH
13435: CALL_OW 189
// AddComEnterUnit ( driver , i ) ;
13439: LD_VAR 0 8
13443: PPUSH
13444: LD_VAR 0 2
13448: PPUSH
13449: CALL_OW 180
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 2 then
13453: LD_VAR 0 2
13457: PPUSH
13458: CALL_OW 256
13462: PUSH
13463: LD_INT 1000
13465: EQUAL
13466: PUSH
13467: LD_VAR 0 2
13471: PPUSH
13472: CALL_OW 110
13476: PUSH
13477: LD_INT 2
13479: EQUAL
13480: AND
13481: IFFALSE 13495
// SetTag ( i , 0 ) ;
13483: LD_VAR 0 2
13487: PPUSH
13488: LD_INT 0
13490: PPUSH
13491: CALL_OW 109
// if not HasTask ( driver ) and GetTag ( i ) <> 2 then
13495: LD_VAR 0 8
13499: PPUSH
13500: CALL_OW 314
13504: NOT
13505: PUSH
13506: LD_VAR 0 2
13510: PPUSH
13511: CALL_OW 110
13515: PUSH
13516: LD_INT 2
13518: NONEQUAL
13519: AND
13520: IFFALSE 13546
// ComAttackUnit ( i , NearestUnitToUnit ( tmp , i ) ) ;
13522: LD_VAR 0 2
13526: PPUSH
13527: LD_VAR 0 11
13531: PPUSH
13532: LD_VAR 0 2
13536: PPUSH
13537: CALL_OW 74
13541: PPUSH
13542: CALL_OW 115
// end ;
13546: GO 13293
13548: POP
13549: POP
// for i in sold do
13550: LD_ADDR_VAR 0 2
13554: PUSH
13555: LD_VAR 0 4
13559: PUSH
13560: FOR_IN
13561: IFFALSE 13816
// begin if GetLives ( i ) < 650 then
13563: LD_VAR 0 2
13567: PPUSH
13568: CALL_OW 256
13572: PUSH
13573: LD_INT 650
13575: LESS
13576: IFFALSE 13590
// SetTag ( i , 3 ) ;
13578: LD_VAR 0 2
13582: PPUSH
13583: LD_INT 3
13585: PPUSH
13586: CALL_OW 109
// if GetTag ( i ) = 3 and not IsInArea ( i , parking ) then
13590: LD_VAR 0 2
13594: PPUSH
13595: CALL_OW 110
13599: PUSH
13600: LD_INT 3
13602: EQUAL
13603: PUSH
13604: LD_VAR 0 2
13608: PPUSH
13609: LD_VAR 0 13
13613: PPUSH
13614: CALL_OW 308
13618: NOT
13619: AND
13620: IFFALSE 13636
// ComMoveToArea ( i , parking ) ;
13622: LD_VAR 0 2
13626: PPUSH
13627: LD_VAR 0 13
13631: PPUSH
13632: CALL_OW 113
// if GetLives ( i ) = 1000 and not GetTag ( i ) in [ 4 , 5 ] then
13636: LD_VAR 0 2
13640: PPUSH
13641: CALL_OW 256
13645: PUSH
13646: LD_INT 1000
13648: EQUAL
13649: PUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: CALL_OW 110
13659: PUSH
13660: LD_INT 4
13662: PUSH
13663: LD_INT 5
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: IN
13670: NOT
13671: AND
13672: IFFALSE 13686
// SetTag ( i , 4 ) ;
13674: LD_VAR 0 2
13678: PPUSH
13679: LD_INT 4
13681: PPUSH
13682: CALL_OW 109
// if GetTag ( i ) = 4 and not IsInArea ( i , soldAttackArea ) then
13686: LD_VAR 0 2
13690: PPUSH
13691: CALL_OW 110
13695: PUSH
13696: LD_INT 4
13698: EQUAL
13699: PUSH
13700: LD_VAR 0 2
13704: PPUSH
13705: LD_VAR 0 15
13709: PPUSH
13710: CALL_OW 308
13714: NOT
13715: AND
13716: IFFALSE 13732
// ComMoveToArea ( i , soldAttackArea ) ;
13718: LD_VAR 0 2
13722: PPUSH
13723: LD_VAR 0 15
13727: PPUSH
13728: CALL_OW 113
// if GetTag ( i ) = 4 and IsInArea ( i , soldAttackArea ) then
13732: LD_VAR 0 2
13736: PPUSH
13737: CALL_OW 110
13741: PUSH
13742: LD_INT 4
13744: EQUAL
13745: PUSH
13746: LD_VAR 0 2
13750: PPUSH
13751: LD_VAR 0 15
13755: PPUSH
13756: CALL_OW 308
13760: AND
13761: IFFALSE 13775
// SetTag ( i , 5 ) ;
13763: LD_VAR 0 2
13767: PPUSH
13768: LD_INT 5
13770: PPUSH
13771: CALL_OW 109
// if GetTag ( i ) = 5 then
13775: LD_VAR 0 2
13779: PPUSH
13780: CALL_OW 110
13784: PUSH
13785: LD_INT 5
13787: EQUAL
13788: IFFALSE 13814
// ComAttackUnit ( i , NearestUnitToUnit ( tmp , i ) ) ;
13790: LD_VAR 0 2
13794: PPUSH
13795: LD_VAR 0 11
13799: PPUSH
13800: LD_VAR 0 2
13804: PPUSH
13805: CALL_OW 74
13809: PPUSH
13810: CALL_OW 115
// end ;
13814: GO 13560
13816: POP
13817: POP
// hurt := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13818: LD_ADDR_VAR 0 9
13822: PUSH
13823: LD_INT 22
13825: PUSH
13826: LD_INT 4
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: LD_INT 21
13835: PUSH
13836: LD_INT 1
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PUSH
13843: LD_INT 3
13845: PUSH
13846: LD_INT 24
13848: PUSH
13849: LD_INT 1000
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: LIST
13864: PPUSH
13865: CALL_OW 69
13869: ST_TO_ADDR
// for i in sci do
13870: LD_ADDR_VAR 0 2
13874: PUSH
13875: LD_VAR 0 7
13879: PUSH
13880: FOR_IN
13881: IFFALSE 14067
// begin if not hurt and not IsInArea ( i , parking ) then
13883: LD_VAR 0 9
13887: NOT
13888: PUSH
13889: LD_VAR 0 2
13893: PPUSH
13894: LD_VAR 0 13
13898: PPUSH
13899: CALL_OW 308
13903: NOT
13904: AND
13905: IFFALSE 13921
// ComMoveToArea ( i , parking ) ;
13907: LD_VAR 0 2
13911: PPUSH
13912: LD_VAR 0 13
13916: PPUSH
13917: CALL_OW 113
// highHurt := UnitFilter ( hurt , [ f_not , [ f_lives , 250 ] ] ) ;
13921: LD_ADDR_VAR 0 10
13925: PUSH
13926: LD_VAR 0 9
13930: PPUSH
13931: LD_INT 3
13933: PUSH
13934: LD_INT 24
13936: PUSH
13937: LD_INT 250
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PPUSH
13948: CALL_OW 72
13952: ST_TO_ADDR
// if highHurt then
13953: LD_VAR 0 10
13957: IFFALSE 13985
// ComHeal ( i , NearestUnitToUnit ( highHurt , i ) ) else
13959: LD_VAR 0 2
13963: PPUSH
13964: LD_VAR 0 10
13968: PPUSH
13969: LD_VAR 0 2
13973: PPUSH
13974: CALL_OW 74
13978: PPUSH
13979: CALL_OW 128
13983: GO 14065
// if UnitFilter ( hurt , [ f_inarea , parking ] ) then
13985: LD_VAR 0 9
13989: PPUSH
13990: LD_INT 95
13992: PUSH
13993: LD_VAR 0 13
13997: PUSH
13998: EMPTY
13999: LIST
14000: LIST
14001: PPUSH
14002: CALL_OW 72
14006: IFFALSE 14051
// ComHeal ( i , NearestUnitToUnit ( UnitFilter ( hurt , [ f_inarea , parking ] ) , i ) ) else
14008: LD_VAR 0 2
14012: PPUSH
14013: LD_VAR 0 9
14017: PPUSH
14018: LD_INT 95
14020: PUSH
14021: LD_VAR 0 13
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: PPUSH
14030: CALL_OW 72
14034: PPUSH
14035: LD_VAR 0 2
14039: PPUSH
14040: CALL_OW 74
14044: PPUSH
14045: CALL_OW 128
14049: GO 14065
// ComMoveToArea ( i , parking ) ;
14051: LD_VAR 0 2
14055: PPUSH
14056: LD_VAR 0 13
14060: PPUSH
14061: CALL_OW 113
// end ;
14065: GO 13880
14067: POP
14068: POP
// end else
14069: GO 14637
// begin for i in vehs do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: LD_VAR 0 12
14080: PUSH
14081: FOR_IN
14082: IFFALSE 14336
// begin driver := IsDrivenBy ( i ) ;
14084: LD_ADDR_VAR 0 8
14088: PUSH
14089: LD_VAR 0 2
14093: PPUSH
14094: CALL_OW 311
14098: ST_TO_ADDR
// if not driver then
14099: LD_VAR 0 8
14103: NOT
14104: IFFALSE 14108
// continue ;
14106: GO 14081
// if GetLives ( i ) < 650 then
14108: LD_VAR 0 2
14112: PPUSH
14113: CALL_OW 256
14117: PUSH
14118: LD_INT 650
14120: LESS
14121: IFFALSE 14135
// SetTag ( i , 2 ) ;
14123: LD_VAR 0 2
14127: PPUSH
14128: LD_INT 2
14130: PPUSH
14131: CALL_OW 109
// if GetLives ( i ) < 1000 and GetTag ( i ) = 2 then
14135: LD_VAR 0 2
14139: PPUSH
14140: CALL_OW 256
14144: PUSH
14145: LD_INT 1000
14147: LESS
14148: PUSH
14149: LD_VAR 0 2
14153: PPUSH
14154: CALL_OW 110
14158: PUSH
14159: LD_INT 2
14161: EQUAL
14162: AND
14163: IFFALSE 14241
// begin if not IsInArea ( i , parking ) then
14165: LD_VAR 0 2
14169: PPUSH
14170: LD_VAR 0 13
14174: PPUSH
14175: CALL_OW 308
14179: NOT
14180: IFFALSE 14198
// ComMoveToArea ( i , parking ) else
14182: LD_VAR 0 2
14186: PPUSH
14187: LD_VAR 0 13
14191: PPUSH
14192: CALL_OW 113
14196: GO 14241
// if driver then
14198: LD_VAR 0 8
14202: IFFALSE 14241
// begin ComExitVehicle ( driver ) ;
14204: LD_VAR 0 8
14208: PPUSH
14209: CALL_OW 121
// AddComRepairVehicle ( driver , i ) ;
14213: LD_VAR 0 8
14217: PPUSH
14218: LD_VAR 0 2
14222: PPUSH
14223: CALL_OW 189
// AddComEnterUnit ( driver , i ) ;
14227: LD_VAR 0 8
14231: PPUSH
14232: LD_VAR 0 2
14236: PPUSH
14237: CALL_OW 180
// end ; end ; if GetLives ( i ) = 1000 and GetTag ( i ) = 2 then
14241: LD_VAR 0 2
14245: PPUSH
14246: CALL_OW 256
14250: PUSH
14251: LD_INT 1000
14253: EQUAL
14254: PUSH
14255: LD_VAR 0 2
14259: PPUSH
14260: CALL_OW 110
14264: PUSH
14265: LD_INT 2
14267: EQUAL
14268: AND
14269: IFFALSE 14283
// SetTag ( i , 0 ) ;
14271: LD_VAR 0 2
14275: PPUSH
14276: LD_INT 0
14278: PPUSH
14279: CALL_OW 109
// if not HasTask ( driver ) and GetTag ( i ) <> 2 then
14283: LD_VAR 0 8
14287: PPUSH
14288: CALL_OW 314
14292: NOT
14293: PUSH
14294: LD_VAR 0 2
14298: PPUSH
14299: CALL_OW 110
14303: PUSH
14304: LD_INT 2
14306: NONEQUAL
14307: AND
14308: IFFALSE 14334
// ComAttackUnit ( i , NearestUnitToUnit ( tmp , i ) ) ;
14310: LD_VAR 0 2
14314: PPUSH
14315: LD_VAR 0 11
14319: PPUSH
14320: LD_VAR 0 2
14324: PPUSH
14325: CALL_OW 74
14329: PPUSH
14330: CALL_OW 115
// end ;
14334: GO 14081
14336: POP
14337: POP
// for i in sold do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: LD_VAR 0 4
14347: PUSH
14348: FOR_IN
14349: IFFALSE 14384
// begin if not IsInArea ( i , parking ) then
14351: LD_VAR 0 2
14355: PPUSH
14356: LD_VAR 0 13
14360: PPUSH
14361: CALL_OW 308
14365: NOT
14366: IFFALSE 14382
// ComMoveToArea ( i , parking ) ;
14368: LD_VAR 0 2
14372: PPUSH
14373: LD_VAR 0 13
14377: PPUSH
14378: CALL_OW 113
// end ;
14382: GO 14348
14384: POP
14385: POP
// hurt := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14386: LD_ADDR_VAR 0 9
14390: PUSH
14391: LD_INT 22
14393: PUSH
14394: LD_INT 4
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: LD_INT 21
14403: PUSH
14404: LD_INT 1
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: PUSH
14411: LD_INT 3
14413: PUSH
14414: LD_INT 24
14416: PUSH
14417: LD_INT 1000
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: LIST
14432: PPUSH
14433: CALL_OW 69
14437: ST_TO_ADDR
// for i in sci do
14438: LD_ADDR_VAR 0 2
14442: PUSH
14443: LD_VAR 0 7
14447: PUSH
14448: FOR_IN
14449: IFFALSE 14635
// begin if not hurt and not IsInArea ( i , parking ) then
14451: LD_VAR 0 9
14455: NOT
14456: PUSH
14457: LD_VAR 0 2
14461: PPUSH
14462: LD_VAR 0 13
14466: PPUSH
14467: CALL_OW 308
14471: NOT
14472: AND
14473: IFFALSE 14489
// ComMoveToArea ( i , parking ) ;
14475: LD_VAR 0 2
14479: PPUSH
14480: LD_VAR 0 13
14484: PPUSH
14485: CALL_OW 113
// highHurt := UnitFilter ( hurt , [ f_not , [ f_lives , 250 ] ] ) ;
14489: LD_ADDR_VAR 0 10
14493: PUSH
14494: LD_VAR 0 9
14498: PPUSH
14499: LD_INT 3
14501: PUSH
14502: LD_INT 24
14504: PUSH
14505: LD_INT 250
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: ST_TO_ADDR
// if highHurt then
14521: LD_VAR 0 10
14525: IFFALSE 14553
// ComHeal ( i , NearestUnitToUnit ( highHurt , i ) ) else
14527: LD_VAR 0 2
14531: PPUSH
14532: LD_VAR 0 10
14536: PPUSH
14537: LD_VAR 0 2
14541: PPUSH
14542: CALL_OW 74
14546: PPUSH
14547: CALL_OW 128
14551: GO 14633
// if UnitFilter ( hurt , [ f_inarea , parking ] ) then
14553: LD_VAR 0 9
14557: PPUSH
14558: LD_INT 95
14560: PUSH
14561: LD_VAR 0 13
14565: PUSH
14566: EMPTY
14567: LIST
14568: LIST
14569: PPUSH
14570: CALL_OW 72
14574: IFFALSE 14619
// ComHeal ( i , NearestUnitToUnit ( UnitFilter ( hurt , [ f_inarea , parking ] ) , i ) ) else
14576: LD_VAR 0 2
14580: PPUSH
14581: LD_VAR 0 9
14585: PPUSH
14586: LD_INT 95
14588: PUSH
14589: LD_VAR 0 13
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 72
14602: PPUSH
14603: LD_VAR 0 2
14607: PPUSH
14608: CALL_OW 74
14612: PPUSH
14613: CALL_OW 128
14617: GO 14633
// ComMoveToArea ( i , parking ) ;
14619: LD_VAR 0 2
14623: PPUSH
14624: LD_VAR 0 13
14628: PPUSH
14629: CALL_OW 113
// end ;
14633: GO 14448
14635: POP
14636: POP
// end ; end ; end ;
14637: GO 11810
// end ;
14639: LD_VAR 0 1
14643: RET
// export function AIEngageEnemy ; var enemy , attacker ; begin
14644: LD_INT 0
14646: PPUSH
14647: PPUSH
14648: PPUSH
// enemy = Filterallunits ( [ f_side , 7 ] ) ;
14649: LD_ADDR_VAR 0 2
14653: PUSH
14654: LD_INT 22
14656: PUSH
14657: LD_INT 7
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PPUSH
14664: CALL_OW 69
14668: ST_TO_ADDR
// if not attack_group then
14669: LD_EXP 47
14673: NOT
14674: IFFALSE 14678
// exit ;
14676: GO 14719
// for attacker in attack_group do
14678: LD_ADDR_VAR 0 3
14682: PUSH
14683: LD_EXP 47
14687: PUSH
14688: FOR_IN
14689: IFFALSE 14717
// ComAttackUnit ( attacker , NearestUnitToUnit ( enemy , attacker ) ) ;
14691: LD_VAR 0 3
14695: PPUSH
14696: LD_VAR 0 2
14700: PPUSH
14701: LD_VAR 0 3
14705: PPUSH
14706: CALL_OW 74
14710: PPUSH
14711: CALL_OW 115
14715: GO 14688
14717: POP
14718: POP
// end ;
14719: LD_VAR 0 1
14723: RET
// every 0 0$1 do
14724: GO 14726
14726: DISABLE
// begin enable ;
14727: ENABLE
// AIEngageEnemy ;
14728: CALL 14644 0 0
// end ;
14732: END
// every 0 0$1 trigger IsSelected ( Kathryn ) or IsSelected ( IsInUnit ( Kathryn ) ) and not ( ( IsDead ( RU2Base1 ) and IsDead ( RU2Base2 ) and IsDead ( RU3_Depot ) ) or KathrynLostControl ) do
14733: LD_EXP 7
14737: PPUSH
14738: CALL_OW 306
14742: PUSH
14743: LD_EXP 7
14747: PPUSH
14748: CALL_OW 310
14752: PPUSH
14753: CALL_OW 306
14757: PUSH
14758: LD_INT 32
14760: PPUSH
14761: CALL_OW 301
14765: PUSH
14766: LD_INT 44
14768: PPUSH
14769: CALL_OW 301
14773: AND
14774: PUSH
14775: LD_INT 167
14777: PPUSH
14778: CALL_OW 301
14782: AND
14783: PUSH
14784: LD_EXP 43
14788: OR
14789: NOT
14790: AND
14791: OR
14792: IFFALSE 16027
14794: GO 14796
14796: DISABLE
// begin if not KathrynOrderAttack then
14797: LD_EXP 41
14801: NOT
14802: IFFALSE 15386
// case Query ( QKathryn1 ) of 1 :
14804: LD_STRING QKathryn1
14806: PPUSH
14807: CALL_OW 97
14811: PUSH
14812: LD_INT 1
14814: DOUBLE
14815: EQUAL
14816: IFTRUE 14820
14818: GO 14941
14820: POP
// begin SimoneCommandIssue ;
14821: CALL 9824 0 0
// case Rand ( 1 , 3 ) of 1 :
14825: LD_INT 1
14827: PPUSH
14828: LD_INT 3
14830: PPUSH
14831: CALL_OW 12
14835: PUSH
14836: LD_INT 1
14838: DOUBLE
14839: EQUAL
14840: IFTRUE 14844
14842: GO 14859
14844: POP
// Say ( Simone , DCommandAttack-Simone-1 ) ; 2 :
14845: LD_EXP 6
14849: PPUSH
14850: LD_STRING DCommandAttack-Simone-1
14852: PPUSH
14853: CALL_OW 88
14857: GO 14906
14859: LD_INT 2
14861: DOUBLE
14862: EQUAL
14863: IFTRUE 14867
14865: GO 14882
14867: POP
// Say ( Simone , DCommandAttack-Simone-2 ) ; 3 :
14868: LD_EXP 6
14872: PPUSH
14873: LD_STRING DCommandAttack-Simone-2
14875: PPUSH
14876: CALL_OW 88
14880: GO 14906
14882: LD_INT 3
14884: DOUBLE
14885: EQUAL
14886: IFTRUE 14890
14888: GO 14905
14890: POP
// Say ( Simone , DCommandAttack-Simone-3 ) ; end ;
14891: LD_EXP 6
14895: PPUSH
14896: LD_STRING DCommandAttack-Simone-3
14898: PPUSH
14899: CALL_OW 88
14903: GO 14906
14905: POP
// if not KathrynOrderAttack then
14906: LD_EXP 41
14910: NOT
14911: IFFALSE 14927
// KathrynMood := KathrynMood + 5 ;
14913: LD_ADDR_EXP 45
14917: PUSH
14918: LD_EXP 45
14922: PUSH
14923: LD_INT 5
14925: PLUS
14926: ST_TO_ADDR
// KathrynOrderAttack := true ;
14927: LD_ADDR_EXP 41
14931: PUSH
14932: LD_INT 1
14934: ST_TO_ADDR
// KathrynCommandAcknowledge ;
14935: CALL 10002 0 0
// end ; 2 :
14939: GO 15384
14941: LD_INT 2
14943: DOUBLE
14944: EQUAL
14945: IFTRUE 14949
14947: GO 15046
14949: POP
// begin SimoneCommandIssue ;
14950: CALL 9824 0 0
// case Rand ( 1 , 2 ) of 1 :
14954: LD_INT 1
14956: PPUSH
14957: LD_INT 2
14959: PPUSH
14960: CALL_OW 12
14964: PUSH
14965: LD_INT 1
14967: DOUBLE
14968: EQUAL
14969: IFTRUE 14973
14971: GO 14988
14973: POP
// Say ( Simone , DCommandHold-Simone-1 ) ; 2 :
14974: LD_EXP 6
14978: PPUSH
14979: LD_STRING DCommandHold-Simone-1
14981: PPUSH
14982: CALL_OW 88
14986: GO 15012
14988: LD_INT 2
14990: DOUBLE
14991: EQUAL
14992: IFTRUE 14996
14994: GO 15011
14996: POP
// Say ( Simone , DCommandHold-Simone-2 ) ; end ;
14997: LD_EXP 6
15001: PPUSH
15002: LD_STRING DCommandHold-Simone-2
15004: PPUSH
15005: CALL_OW 88
15009: GO 15012
15011: POP
// if KathrynOrderAttack then
15012: LD_EXP 41
15016: IFFALSE 15032
// KathrynMood := KathrynMood - 5 ;
15018: LD_ADDR_EXP 45
15022: PUSH
15023: LD_EXP 45
15027: PUSH
15028: LD_INT 5
15030: MINUS
15031: ST_TO_ADDR
// KathrynOrderAttack := false ;
15032: LD_ADDR_EXP 41
15036: PUSH
15037: LD_INT 0
15039: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15040: CALL 10002 0 0
// end ; 3 :
15044: GO 15384
15046: LD_INT 3
15048: DOUBLE
15049: EQUAL
15050: IFTRUE 15054
15052: GO 15383
15054: POP
// begin case Query ( QKathrynTactics ) of 1 :
15055: LD_STRING QKathrynTactics
15057: PPUSH
15058: CALL_OW 97
15062: PUSH
15063: LD_INT 1
15065: DOUBLE
15066: EQUAL
15067: IFTRUE 15071
15069: GO 15177
15071: POP
// begin SimoneCommandIssue ;
15072: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15076: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15080: LD_INT 1
15082: PPUSH
15083: LD_INT 2
15085: PPUSH
15086: CALL_OW 12
15090: PUSH
15091: LD_INT 1
15093: DOUBLE
15094: EQUAL
15095: IFTRUE 15099
15097: GO 15114
15099: POP
// Say ( Simone , DCommandTacticsHardcore-Simone-1 ) ; 2 :
15100: LD_EXP 6
15104: PPUSH
15105: LD_STRING DCommandTacticsHardcore-Simone-1
15107: PPUSH
15108: CALL_OW 88
15112: GO 15138
15114: LD_INT 2
15116: DOUBLE
15117: EQUAL
15118: IFTRUE 15122
15120: GO 15137
15122: POP
// Say ( Simone , DCommandTacticsHardcore-Simone-2 ) ; end ;
15123: LD_EXP 6
15127: PPUSH
15128: LD_STRING DCommandTacticsHardcore-Simone-2
15130: PPUSH
15131: CALL_OW 88
15135: GO 15138
15137: POP
// if not KathrynAttackStance = 1 then
15138: LD_EXP 42
15142: PUSH
15143: LD_INT 1
15145: EQUAL
15146: NOT
15147: IFFALSE 15163
// KathrynMood := KathrynMood + 2 ;
15149: LD_ADDR_EXP 45
15153: PUSH
15154: LD_EXP 45
15158: PUSH
15159: LD_INT 2
15161: PLUS
15162: ST_TO_ADDR
// KathrynAttackStance = 1 ;
15163: LD_ADDR_EXP 42
15167: PUSH
15168: LD_INT 1
15170: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15171: CALL 10002 0 0
// end ; 2 :
15175: GO 15381
15177: LD_INT 2
15179: DOUBLE
15180: EQUAL
15181: IFTRUE 15185
15183: GO 15266
15185: POP
// begin SimoneCommandIssue ;
15186: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15190: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15194: LD_INT 1
15196: PPUSH
15197: LD_INT 2
15199: PPUSH
15200: CALL_OW 12
15204: PUSH
15205: LD_INT 1
15207: DOUBLE
15208: EQUAL
15209: IFTRUE 15213
15211: GO 15228
15213: POP
// Say ( Simone , DCommandTacticsBalanced-Simone-1 ) ; 2 :
15214: LD_EXP 6
15218: PPUSH
15219: LD_STRING DCommandTacticsBalanced-Simone-1
15221: PPUSH
15222: CALL_OW 88
15226: GO 15252
15228: LD_INT 2
15230: DOUBLE
15231: EQUAL
15232: IFTRUE 15236
15234: GO 15251
15236: POP
// Say ( Simone , DCommandTacticsBalanced-Simone-2 ) ; end ;
15237: LD_EXP 6
15241: PPUSH
15242: LD_STRING DCommandTacticsBalanced-Simone-2
15244: PPUSH
15245: CALL_OW 88
15249: GO 15252
15251: POP
// KathrynAttackStance = 2 ;
15252: LD_ADDR_EXP 42
15256: PUSH
15257: LD_INT 2
15259: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15260: CALL 10002 0 0
// end ; 3 :
15264: GO 15381
15266: LD_INT 3
15268: DOUBLE
15269: EQUAL
15270: IFTRUE 15274
15272: GO 15380
15274: POP
// begin SimoneCommandIssue ;
15275: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15279: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15283: LD_INT 1
15285: PPUSH
15286: LD_INT 2
15288: PPUSH
15289: CALL_OW 12
15293: PUSH
15294: LD_INT 1
15296: DOUBLE
15297: EQUAL
15298: IFTRUE 15302
15300: GO 15317
15302: POP
// Say ( Simone , DCommandTacticsSlow-Simone-1 ) ; 2 :
15303: LD_EXP 6
15307: PPUSH
15308: LD_STRING DCommandTacticsSlow-Simone-1
15310: PPUSH
15311: CALL_OW 88
15315: GO 15341
15317: LD_INT 2
15319: DOUBLE
15320: EQUAL
15321: IFTRUE 15325
15323: GO 15340
15325: POP
// Say ( Simone , DCommandTacticsSlow-Simone-2 ) ; end ;
15326: LD_EXP 6
15330: PPUSH
15331: LD_STRING DCommandTacticsSlow-Simone-2
15333: PPUSH
15334: CALL_OW 88
15338: GO 15341
15340: POP
// if not KathrynAttackStance = 3 then
15341: LD_EXP 42
15345: PUSH
15346: LD_INT 3
15348: EQUAL
15349: NOT
15350: IFFALSE 15366
// KathrynMood := KathrynMood - 2 ;
15352: LD_ADDR_EXP 45
15356: PUSH
15357: LD_EXP 45
15361: PUSH
15362: LD_INT 2
15364: MINUS
15365: ST_TO_ADDR
// KathrynAttackStance = 3 ;
15366: LD_ADDR_EXP 42
15370: PUSH
15371: LD_INT 3
15373: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15374: CALL 10002 0 0
// end ; end ;
15378: GO 15381
15380: POP
// end ; end else
15381: GO 15384
15383: POP
15384: GO 16019
// case Query ( QKathryn2 ) of 1 :
15386: LD_STRING QKathryn2
15388: PPUSH
15389: CALL_OW 97
15393: PUSH
15394: LD_INT 1
15396: DOUBLE
15397: EQUAL
15398: IFTRUE 15402
15400: GO 15576
15402: POP
// begin SimoneCommandIssue ;
15403: CALL 9824 0 0
// case Rand ( 1 , 2 ) of 1 :
15407: LD_INT 1
15409: PPUSH
15410: LD_INT 2
15412: PPUSH
15413: CALL_OW 12
15417: PUSH
15418: LD_INT 1
15420: DOUBLE
15421: EQUAL
15422: IFTRUE 15426
15424: GO 15441
15426: POP
// Say ( Simone , DCommandRetreat-Simone-1 ) ; 2 :
15427: LD_EXP 6
15431: PPUSH
15432: LD_STRING DCommandRetreat-Simone-1
15434: PPUSH
15435: CALL_OW 88
15439: GO 15465
15441: LD_INT 2
15443: DOUBLE
15444: EQUAL
15445: IFTRUE 15449
15447: GO 15464
15449: POP
// Say ( Simone , DCommandRetreat-Simone-2 ) ; end ;
15450: LD_EXP 6
15454: PPUSH
15455: LD_STRING DCommandRetreat-Simone-2
15457: PPUSH
15458: CALL_OW 88
15462: GO 15465
15464: POP
// if KathrynOrderAttack then
15465: LD_EXP 41
15469: IFFALSE 15485
// KathrynMood := KathrynMood - 15 ;
15471: LD_ADDR_EXP 45
15475: PUSH
15476: LD_EXP 45
15480: PUSH
15481: LD_INT 15
15483: MINUS
15484: ST_TO_ADDR
// KathrynOrderAttack := false ;
15485: LD_ADDR_EXP 41
15489: PUSH
15490: LD_INT 0
15492: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
15493: LD_INT 1
15495: PPUSH
15496: LD_INT 3
15498: PPUSH
15499: CALL_OW 12
15503: PUSH
15504: LD_INT 1
15506: DOUBLE
15507: EQUAL
15508: IFTRUE 15512
15510: GO 15527
15512: POP
// SayRadio ( Kathryn , DCommandAcknowledgeRetreat-Kathryn-1 ) ; 2 :
15513: LD_EXP 7
15517: PPUSH
15518: LD_STRING DCommandAcknowledgeRetreat-Kathryn-1
15520: PPUSH
15521: CALL_OW 94
15525: GO 15574
15527: LD_INT 2
15529: DOUBLE
15530: EQUAL
15531: IFTRUE 15535
15533: GO 15550
15535: POP
// SayRadio ( Kathryn , DCommandAcknowledgeRetreat-Kathryn-2 ) ; 3 :
15536: LD_EXP 7
15540: PPUSH
15541: LD_STRING DCommandAcknowledgeRetreat-Kathryn-2
15543: PPUSH
15544: CALL_OW 94
15548: GO 15574
15550: LD_INT 3
15552: DOUBLE
15553: EQUAL
15554: IFTRUE 15558
15556: GO 15573
15558: POP
// SayRadio ( Kathryn , DCommandAcknowledgeRetreat-Kathryn-3 ) ; end ;
15559: LD_EXP 7
15563: PPUSH
15564: LD_STRING DCommandAcknowledgeRetreat-Kathryn-3
15566: PPUSH
15567: CALL_OW 94
15571: GO 15574
15573: POP
// end ; 2 :
15574: GO 16019
15576: LD_INT 2
15578: DOUBLE
15579: EQUAL
15580: IFTRUE 15584
15582: GO 15681
15584: POP
// begin SimoneCommandIssue ;
15585: CALL 9824 0 0
// case Rand ( 1 , 2 ) of 1 :
15589: LD_INT 1
15591: PPUSH
15592: LD_INT 2
15594: PPUSH
15595: CALL_OW 12
15599: PUSH
15600: LD_INT 1
15602: DOUBLE
15603: EQUAL
15604: IFTRUE 15608
15606: GO 15623
15608: POP
// Say ( Simone , DCommandHold-Simone-1 ) ; 2 :
15609: LD_EXP 6
15613: PPUSH
15614: LD_STRING DCommandHold-Simone-1
15616: PPUSH
15617: CALL_OW 88
15621: GO 15647
15623: LD_INT 2
15625: DOUBLE
15626: EQUAL
15627: IFTRUE 15631
15629: GO 15646
15631: POP
// Say ( Simone , DCommandHold-Simone-2 ) ; end ;
15632: LD_EXP 6
15636: PPUSH
15637: LD_STRING DCommandHold-Simone-2
15639: PPUSH
15640: CALL_OW 88
15644: GO 15647
15646: POP
// if KathrynOrderAttack then
15647: LD_EXP 41
15651: IFFALSE 15667
// KathrynMood := KathrynMood - 5 ;
15653: LD_ADDR_EXP 45
15657: PUSH
15658: LD_EXP 45
15662: PUSH
15663: LD_INT 5
15665: MINUS
15666: ST_TO_ADDR
// KathrynOrderAttack := false ;
15667: LD_ADDR_EXP 41
15671: PUSH
15672: LD_INT 0
15674: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15675: CALL 10002 0 0
// end ; 3 :
15679: GO 16019
15681: LD_INT 3
15683: DOUBLE
15684: EQUAL
15685: IFTRUE 15689
15687: GO 16018
15689: POP
// begin case Query ( QKathrynTactics ) of 1 :
15690: LD_STRING QKathrynTactics
15692: PPUSH
15693: CALL_OW 97
15697: PUSH
15698: LD_INT 1
15700: DOUBLE
15701: EQUAL
15702: IFTRUE 15706
15704: GO 15812
15706: POP
// begin SimoneCommandIssue ;
15707: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15711: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15715: LD_INT 1
15717: PPUSH
15718: LD_INT 2
15720: PPUSH
15721: CALL_OW 12
15725: PUSH
15726: LD_INT 1
15728: DOUBLE
15729: EQUAL
15730: IFTRUE 15734
15732: GO 15749
15734: POP
// Say ( Simone , DCommandTacticsHardcore-Simone-1 ) ; 2 :
15735: LD_EXP 6
15739: PPUSH
15740: LD_STRING DCommandTacticsHardcore-Simone-1
15742: PPUSH
15743: CALL_OW 88
15747: GO 15773
15749: LD_INT 2
15751: DOUBLE
15752: EQUAL
15753: IFTRUE 15757
15755: GO 15772
15757: POP
// Say ( Simone , DCommandTacticsHardcore-Simone-2 ) ; end ;
15758: LD_EXP 6
15762: PPUSH
15763: LD_STRING DCommandTacticsHardcore-Simone-2
15765: PPUSH
15766: CALL_OW 88
15770: GO 15773
15772: POP
// if not KathrynAttackStance = 1 then
15773: LD_EXP 42
15777: PUSH
15778: LD_INT 1
15780: EQUAL
15781: NOT
15782: IFFALSE 15798
// KathrynMood := KathrynMood + 5 ;
15784: LD_ADDR_EXP 45
15788: PUSH
15789: LD_EXP 45
15793: PUSH
15794: LD_INT 5
15796: PLUS
15797: ST_TO_ADDR
// KathrynAttackStance = 1 ;
15798: LD_ADDR_EXP 42
15802: PUSH
15803: LD_INT 1
15805: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15806: CALL 10002 0 0
// end ; 2 :
15810: GO 16016
15812: LD_INT 2
15814: DOUBLE
15815: EQUAL
15816: IFTRUE 15820
15818: GO 15901
15820: POP
// begin SimoneCommandIssue ;
15821: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15825: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15829: LD_INT 1
15831: PPUSH
15832: LD_INT 2
15834: PPUSH
15835: CALL_OW 12
15839: PUSH
15840: LD_INT 1
15842: DOUBLE
15843: EQUAL
15844: IFTRUE 15848
15846: GO 15863
15848: POP
// Say ( Simone , DCommandTacticsBalanced-Simone-1 ) ; 2 :
15849: LD_EXP 6
15853: PPUSH
15854: LD_STRING DCommandTacticsBalanced-Simone-1
15856: PPUSH
15857: CALL_OW 88
15861: GO 15887
15863: LD_INT 2
15865: DOUBLE
15866: EQUAL
15867: IFTRUE 15871
15869: GO 15886
15871: POP
// Say ( Simone , DCommandTacticsBalanced-Simone-2 ) ; end ;
15872: LD_EXP 6
15876: PPUSH
15877: LD_STRING DCommandTacticsBalanced-Simone-2
15879: PPUSH
15880: CALL_OW 88
15884: GO 15887
15886: POP
// KathrynAttackStance = 2 ;
15887: LD_ADDR_EXP 42
15891: PUSH
15892: LD_INT 2
15894: ST_TO_ADDR
// KathrynCommandAcknowledge ;
15895: CALL 10002 0 0
// end ; 3 :
15899: GO 16016
15901: LD_INT 3
15903: DOUBLE
15904: EQUAL
15905: IFTRUE 15909
15907: GO 16015
15909: POP
// begin SimoneCommandIssue ;
15910: CALL 9824 0 0
// SimoneCommandTacticsIssue ;
15914: CALL 9913 0 0
// case Rand ( 1 , 2 ) of 1 :
15918: LD_INT 1
15920: PPUSH
15921: LD_INT 2
15923: PPUSH
15924: CALL_OW 12
15928: PUSH
15929: LD_INT 1
15931: DOUBLE
15932: EQUAL
15933: IFTRUE 15937
15935: GO 15952
15937: POP
// Say ( Simone , DCommandTacticsSlow-Simone-1 ) ; 2 :
15938: LD_EXP 6
15942: PPUSH
15943: LD_STRING DCommandTacticsSlow-Simone-1
15945: PPUSH
15946: CALL_OW 88
15950: GO 15976
15952: LD_INT 2
15954: DOUBLE
15955: EQUAL
15956: IFTRUE 15960
15958: GO 15975
15960: POP
// Say ( Simone , DCommandTacticsSlow-Simone-2 ) ; end ;
15961: LD_EXP 6
15965: PPUSH
15966: LD_STRING DCommandTacticsSlow-Simone-2
15968: PPUSH
15969: CALL_OW 88
15973: GO 15976
15975: POP
// if not KathrynAttackStance = 3 then
15976: LD_EXP 42
15980: PUSH
15981: LD_INT 3
15983: EQUAL
15984: NOT
15985: IFFALSE 16001
// KathrynMood := KathrynMood - 5 ;
15987: LD_ADDR_EXP 45
15991: PUSH
15992: LD_EXP 45
15996: PUSH
15997: LD_INT 5
15999: MINUS
16000: ST_TO_ADDR
// KathrynAttackStance = 3 ;
16001: LD_ADDR_EXP 42
16005: PUSH
16006: LD_INT 3
16008: ST_TO_ADDR
// KathrynCommandAcknowledge ;
16009: CALL 10002 0 0
// end ; end ;
16013: GO 16016
16015: POP
// end ; end ;
16016: GO 16019
16018: POP
// wait ( 0 0$3 ) ;
16019: LD_INT 105
16021: PPUSH
16022: CALL_OW 67
// enable ;
16026: ENABLE
// end ; end_of_file
16027: END
// export GeorgiansEncountered , GeorgiansSecondEncounter ; export GeoAttacksAppeared ; every 7 7$0 + 5 5$0 trigger GeorgianAttacks > 0 do var GeoAttackAreas , GeoAttacksAppeared ;
16028: LD_EXP 36
16032: PUSH
16033: LD_INT 0
16035: GREATER
16036: IFFALSE 16363
16038: GO 16040
16040: DISABLE
16041: LD_INT 0
16043: PPUSH
16044: PPUSH
// begin enable ;
16045: ENABLE
// GeoAttackAreas := GeoAttackArea1 ^ GeoAttackArea2 ;
16046: LD_ADDR_VAR 0 1
16050: PUSH
16051: LD_INT 8
16053: PUSH
16054: LD_INT 9
16056: ADD
16057: ST_TO_ADDR
// RespawnAttackVehicle ( GeoAttackAreas [ Rand ( 1 , GeoAttackAreas ) ] , 8 , Rand ( 3 , 6 ) , Rand ( 7 , 9 ) , 2 , engine_siberite , control_manual , [ ] , [ 25 , 27 , 28 , 72 , 73 , 71 ] , [ ] ) ;
16058: LD_VAR 0 1
16062: PUSH
16063: LD_INT 1
16065: PPUSH
16066: LD_VAR 0 1
16070: PPUSH
16071: CALL_OW 12
16075: ARRAY
16076: PPUSH
16077: LD_INT 8
16079: PPUSH
16080: LD_INT 3
16082: PPUSH
16083: LD_INT 6
16085: PPUSH
16086: CALL_OW 12
16090: PPUSH
16091: LD_INT 7
16093: PPUSH
16094: LD_INT 9
16096: PPUSH
16097: CALL_OW 12
16101: PPUSH
16102: LD_INT 2
16104: PPUSH
16105: LD_INT 3
16107: PPUSH
16108: LD_INT 1
16110: PPUSH
16111: EMPTY
16112: PPUSH
16113: LD_INT 25
16115: PUSH
16116: LD_INT 27
16118: PUSH
16119: LD_INT 28
16121: PUSH
16122: LD_INT 72
16124: PUSH
16125: LD_INT 73
16127: PUSH
16128: LD_INT 71
16130: PUSH
16131: EMPTY
16132: LIST
16133: LIST
16134: LIST
16135: LIST
16136: LIST
16137: LIST
16138: PPUSH
16139: EMPTY
16140: PPUSH
16141: CALL 8275 0 10
// GeorgianAttacks := GeorgianAttacks - 1 ;
16145: LD_ADDR_EXP 36
16149: PUSH
16150: LD_EXP 36
16154: PUSH
16155: LD_INT 1
16157: MINUS
16158: ST_TO_ADDR
// GeoAttacksAppeared := GeoAttacksAppeared + 1 ;
16159: LD_ADDR_VAR 0 2
16163: PUSH
16164: LD_VAR 0 2
16168: PUSH
16169: LD_INT 1
16171: PLUS
16172: ST_TO_ADDR
// if not GeorgiansEncountered and GeoAttacksAppeared > 0 then
16173: LD_EXP 48
16177: NOT
16178: PUSH
16179: LD_VAR 0 2
16183: PUSH
16184: LD_INT 0
16186: GREATER
16187: AND
16188: IFFALSE 16278
// begin GeorgiansEncountered := true ;
16190: LD_ADDR_EXP 48
16194: PUSH
16195: LD_INT 1
16197: ST_TO_ADDR
// DialogueOn ;
16198: CALL_OW 6
// Say ( Simone , D2a-Simone-1 ) ;
16202: LD_EXP 6
16206: PPUSH
16207: LD_STRING D2a-Simone-1
16209: PPUSH
16210: CALL_OW 88
// Say ( Miller , D2a-Miller-2 ) ;
16214: LD_EXP 8
16218: PPUSH
16219: LD_STRING D2a-Miller-2
16221: PPUSH
16222: CALL_OW 88
// SayRadio ( Dvalishvili , D2a-Dvali-1 ) ;
16226: LD_EXP 15
16230: PPUSH
16231: LD_STRING D2a-Dvali-1
16233: PPUSH
16234: CALL_OW 94
// Say ( Simone , D2a-Simone-2 ) ;
16238: LD_EXP 6
16242: PPUSH
16243: LD_STRING D2a-Simone-2
16245: PPUSH
16246: CALL_OW 88
// SayRadio ( Dvalishvili , D2a-Dvali-2 ) ;
16250: LD_EXP 15
16254: PPUSH
16255: LD_STRING D2a-Dvali-2
16257: PPUSH
16258: CALL_OW 94
// Say ( Simone , D2a-Simone-3 ) ;
16262: LD_EXP 6
16266: PPUSH
16267: LD_STRING D2a-Simone-3
16269: PPUSH
16270: CALL_OW 88
// DialogueOff ;
16274: CALL_OW 7
// end ; if GeorgiansEncountered and not GeorgiansSecondEncounter and GeoAttacksAppeared > 1 then
16278: LD_EXP 48
16282: PUSH
16283: LD_EXP 49
16287: NOT
16288: AND
16289: PUSH
16290: LD_VAR 0 2
16294: PUSH
16295: LD_INT 1
16297: GREATER
16298: AND
16299: IFFALSE 16363
// begin GeorgiansSecondEncounter := true ;
16301: LD_ADDR_EXP 49
16305: PUSH
16306: LD_INT 1
16308: ST_TO_ADDR
// DialogueOn ;
16309: CALL_OW 6
// Say ( Simone , D3-Simone-1 ) ;
16313: LD_EXP 6
16317: PPUSH
16318: LD_STRING D3-Simone-1
16320: PPUSH
16321: CALL_OW 88
// Say ( Miller , D3-Miller-1 ) ;
16325: LD_EXP 8
16329: PPUSH
16330: LD_STRING D3-Miller-1
16332: PPUSH
16333: CALL_OW 88
// if ConvoysEscaped > 0 then
16337: LD_EXP 23
16341: PUSH
16342: LD_INT 0
16344: GREATER
16345: IFFALSE 16359
// Say ( Simone , D3a-Simone-1 ) ;
16347: LD_EXP 6
16351: PPUSH
16352: LD_STRING D3a-Simone-1
16354: PPUSH
16355: CALL_OW 88
// DialogueOff ;
16359: CALL_OW 7
// end ; end ; end_of_file
16363: PPOPN 2
16365: END
// on UnitDestroyed ( un ) do begin if un = Simone then
16366: LD_VAR 0 1
16370: PUSH
16371: LD_EXP 6
16375: EQUAL
16376: IFFALSE 16404
// begin ExclusiveOn ;
16378: CALL_OW 4
// Wait ( 0 0$2 ) ;
16382: LD_INT 70
16384: PPUSH
16385: CALL_OW 67
// YouLost ( Simone ) ;
16389: LD_STRING Simone
16391: PPUSH
16392: CALL_OW 104
// ExclusiveOff ;
16396: CALL_OW 5
// exit ;
16400: GO 16485
// end else
16402: GO 16485
// if un = Kathryn and not ReachedBase then
16404: LD_VAR 0 1
16408: PUSH
16409: LD_EXP 7
16413: EQUAL
16414: PUSH
16415: LD_EXP 3
16419: NOT
16420: AND
16421: IFFALSE 16449
// begin ExclusiveOn ;
16423: CALL_OW 4
// Wait ( 0 0$2 ) ;
16427: LD_INT 70
16429: PPUSH
16430: CALL_OW 67
// YouLost ( Kathryn ) ;
16434: LD_STRING Kathryn
16436: PPUSH
16437: CALL_OW 104
// ExclusiveOff ;
16441: CALL_OW 5
// exit ;
16445: GO 16485
// end else
16447: GO 16485
// if un = Miller then
16449: LD_VAR 0 1
16453: PUSH
16454: LD_EXP 8
16458: EQUAL
16459: IFFALSE 16485
// begin ExclusiveOn ;
16461: CALL_OW 4
// Wait ( 0 0$2 ) ;
16465: LD_INT 70
16467: PPUSH
16468: CALL_OW 67
// YouLost ( Miller ) ;
16472: LD_STRING Miller
16474: PPUSH
16475: CALL_OW 104
// ExclusiveOff ;
16479: CALL_OW 5
// exit ;
16483: GO 16485
// end end ;
16485: PPOPN 1
16487: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and not ReachedBase then
16488: LD_VAR 0 1
16492: PPUSH
16493: CALL_OW 255
16497: PUSH
16498: LD_INT 4
16500: EQUAL
16501: PUSH
16502: LD_EXP 3
16506: NOT
16507: AND
16508: IFFALSE 16538
// begin ComRepairVehicle ( driver , abandoned_vehicle ) ;
16510: LD_VAR 0 1
16514: PPUSH
16515: LD_VAR 0 2
16519: PPUSH
16520: CALL_OW 129
// AddComEnterUnit ( driver , abandoned_vehicle ) ;
16524: LD_VAR 0 1
16528: PPUSH
16529: LD_VAR 0 2
16533: PPUSH
16534: CALL_OW 180
// end ; end ;
16538: PPOPN 4
16540: END
// on LeaveVehicle ( vehicle , driver ) do begin if GetSide ( driver ) = 4 and not ReachedBase then
16541: LD_VAR 0 2
16545: PPUSH
16546: CALL_OW 255
16550: PUSH
16551: LD_INT 4
16553: EQUAL
16554: PUSH
16555: LD_EXP 3
16559: NOT
16560: AND
16561: IFFALSE 16591
// begin ComRepairVehicle ( driver , vehicle ) ;
16563: LD_VAR 0 2
16567: PPUSH
16568: LD_VAR 0 1
16572: PPUSH
16573: CALL_OW 129
// AddComEnterUnit ( driver , vehicle ) ;
16577: LD_VAR 0 2
16581: PPUSH
16582: LD_VAR 0 1
16586: PPUSH
16587: CALL_OW 180
// end ; end ; end_of_file
16591: PPOPN 2
16593: END
// every 0 0$1 do
16594: GO 16596
16596: DISABLE
// begin enable ;
16597: ENABLE
// if debug then
16598: LD_EXP 2
16602: IFFALSE 16678
// begin display_strings := [ [ mood , KathrynMood ] , [ status , KathrynStatus ] , [ stance , KathrynAttackStance ] , [ attack , KathrynOrderAttack ] , [ lost , KathrynLostControl ] ] ;
16604: LD_ADDR_OWVAR 47
16608: PUSH
16609: LD_STRING mood
16611: PUSH
16612: LD_EXP 45
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: PUSH
16621: LD_STRING status
16623: PUSH
16624: LD_EXP 46
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: PUSH
16633: LD_STRING stance
16635: PUSH
16636: LD_EXP 42
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PUSH
16645: LD_STRING attack
16647: PUSH
16648: LD_EXP 41
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_STRING lost
16659: PUSH
16660: LD_EXP 43
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: PUSH
16669: EMPTY
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: ST_TO_ADDR
// exit ;
16676: GO 16862
// end ; if ReachedBase then
16678: LD_EXP 3
16682: IFFALSE 16692
// begin Display_Strings :=  ;
16684: LD_ADDR_OWVAR 47
16688: PUSH
16689: LD_STRING 
16691: ST_TO_ADDR
// end ; if KathrynMood >= 70 and not ReachedBase then
16692: LD_EXP 45
16696: PUSH
16697: LD_INT 70
16699: GREATEREQUAL
16700: PUSH
16701: LD_EXP 3
16705: NOT
16706: AND
16707: IFFALSE 16720
// begin Display_Strings := [ #Am04-KathrynMoodGood ] ;
16709: LD_ADDR_OWVAR 47
16713: PUSH
16714: LD_STRING #Am04-KathrynMoodGood
16716: PUSH
16717: EMPTY
16718: LIST
16719: ST_TO_ADDR
// end ; if KathrynMood >= 40 and KathrynMood < 70 and not ReachedBase then
16720: LD_EXP 45
16724: PUSH
16725: LD_INT 40
16727: GREATEREQUAL
16728: PUSH
16729: LD_EXP 45
16733: PUSH
16734: LD_INT 70
16736: LESS
16737: AND
16738: PUSH
16739: LD_EXP 3
16743: NOT
16744: AND
16745: IFFALSE 16758
// begin Display_Strings := [ #Am04-KathrynMoodAverage ] ;
16747: LD_ADDR_OWVAR 47
16751: PUSH
16752: LD_STRING #Am04-KathrynMoodAverage
16754: PUSH
16755: EMPTY
16756: LIST
16757: ST_TO_ADDR
// end ; if KathrynMood >= 15 and KathrynMood < 40 and not ReachedBase then
16758: LD_EXP 45
16762: PUSH
16763: LD_INT 15
16765: GREATEREQUAL
16766: PUSH
16767: LD_EXP 45
16771: PUSH
16772: LD_INT 40
16774: LESS
16775: AND
16776: PUSH
16777: LD_EXP 3
16781: NOT
16782: AND
16783: IFFALSE 16796
// begin Display_Strings := [ #Am04-KathrynMoodBad ] ;
16785: LD_ADDR_OWVAR 47
16789: PUSH
16790: LD_STRING #Am04-KathrynMoodBad
16792: PUSH
16793: EMPTY
16794: LIST
16795: ST_TO_ADDR
// end ; if KathrynMood > 0 and KathrynMood < 15 and not ReachedBase then
16796: LD_EXP 45
16800: PUSH
16801: LD_INT 0
16803: GREATER
16804: PUSH
16805: LD_EXP 45
16809: PUSH
16810: LD_INT 15
16812: LESS
16813: AND
16814: PUSH
16815: LD_EXP 3
16819: NOT
16820: AND
16821: IFFALSE 16834
// begin Display_Strings := [ #Am04-KathrynMoodVeryBad ] ;
16823: LD_ADDR_OWVAR 47
16827: PUSH
16828: LD_STRING #Am04-KathrynMoodVeryBad
16830: PUSH
16831: EMPTY
16832: LIST
16833: ST_TO_ADDR
// end ; if KathrynMood = 0 and not ReachedBase then
16834: LD_EXP 45
16838: PUSH
16839: LD_INT 0
16841: EQUAL
16842: PUSH
16843: LD_EXP 3
16847: NOT
16848: AND
16849: IFFALSE 16862
// begin Display_Strings := [ #Am04-KathrynMoodLostControl ] ;
16851: LD_ADDR_OWVAR 47
16855: PUSH
16856: LD_STRING #Am04-KathrynMoodLostControl
16858: PUSH
16859: EMPTY
16860: LIST
16861: ST_TO_ADDR
// end ; end ;
16862: END
// every 0 0$1 trigger ( not ReachedBase or not KathrynStatus = 4 ) and not KathrynLostControl do
16863: LD_EXP 3
16867: NOT
16868: PUSH
16869: LD_EXP 46
16873: PUSH
16874: LD_INT 4
16876: EQUAL
16877: NOT
16878: OR
16879: PUSH
16880: LD_EXP 43
16884: NOT
16885: AND
16886: IFFALSE 16933
16888: GO 16890
16890: DISABLE
// begin wait ( 1 1$0 ) ;
16891: LD_INT 2100
16893: PPUSH
16894: CALL_OW 67
// if not KathrynOrderAttack or not KathrynStatus = 4 then
16898: LD_EXP 41
16902: NOT
16903: PUSH
16904: LD_EXP 46
16908: PUSH
16909: LD_INT 4
16911: EQUAL
16912: NOT
16913: OR
16914: IFFALSE 16932
// KathrynMood := KathrynMood - KathrynMoodIdleDropCoeficent ;
16916: LD_ADDR_EXP 45
16920: PUSH
16921: LD_EXP 45
16925: PUSH
16926: LD_EXP 40
16930: MINUS
16931: ST_TO_ADDR
// enable ;
16932: ENABLE
// end ;
16933: END
// every 0 0$1 trigger KathrynMood < 70 and not KathrynOrderAttack and not ReachedBase do
16934: LD_EXP 45
16938: PUSH
16939: LD_INT 70
16941: LESS
16942: PUSH
16943: LD_EXP 41
16947: NOT
16948: AND
16949: PUSH
16950: LD_EXP 3
16954: NOT
16955: AND
16956: IFFALSE 16980
16958: GO 16960
16960: DISABLE
// begin wait ( 0 0$5 ) ;
16961: LD_INT 175
16963: PPUSH
16964: CALL_OW 67
// SayRadio ( Kathryn , DCommandIdle-Kathryn-1 ) ;
16968: LD_EXP 7
16972: PPUSH
16973: LD_STRING DCommandIdle-Kathryn-1
16975: PPUSH
16976: CALL_OW 94
// end ;
16980: END
// every 0 0$1 trigger KathrynMood < 40 and not KathrynOrderAttack and not ReachedBase do
16981: LD_EXP 45
16985: PUSH
16986: LD_INT 40
16988: LESS
16989: PUSH
16990: LD_EXP 41
16994: NOT
16995: AND
16996: PUSH
16997: LD_EXP 3
17001: NOT
17002: AND
17003: IFFALSE 17027
17005: GO 17007
17007: DISABLE
// begin wait ( 0 0$5 ) ;
17008: LD_INT 175
17010: PPUSH
17011: CALL_OW 67
// SayRadio ( Kathryn , DCommandIdle-Kathryn-2 ) ;
17015: LD_EXP 7
17019: PPUSH
17020: LD_STRING DCommandIdle-Kathryn-2
17022: PPUSH
17023: CALL_OW 94
// end ;
17027: END
// every 0 0$1 trigger KathrynMood < 20 and not KathrynOrderAttack and not ReachedBase do
17028: LD_EXP 45
17032: PUSH
17033: LD_INT 20
17035: LESS
17036: PUSH
17037: LD_EXP 41
17041: NOT
17042: AND
17043: PUSH
17044: LD_EXP 3
17048: NOT
17049: AND
17050: IFFALSE 17074
17052: GO 17054
17054: DISABLE
// begin wait ( 0 0$5 ) ;
17055: LD_INT 175
17057: PPUSH
17058: CALL_OW 67
// SayRadio ( Kathryn , DCommandIdle-Kathryn-3 ) ;
17062: LD_EXP 7
17066: PPUSH
17067: LD_STRING DCommandIdle-Kathryn-3
17069: PPUSH
17070: CALL_OW 94
// end ;
17074: END
// every 0 0$1 trigger KathrynMood = 0 and not ReachedBase do
17075: LD_EXP 45
17079: PUSH
17080: LD_INT 0
17082: EQUAL
17083: PUSH
17084: LD_EXP 3
17088: NOT
17089: AND
17090: IFFALSE 17251
17092: GO 17094
17094: DISABLE
// begin DialogueOn ;
17095: CALL_OW 6
// KathrynLostControl := true ;
17099: LD_ADDR_EXP 43
17103: PUSH
17104: LD_INT 1
17106: ST_TO_ADDR
// case Rand ( 1 , 2 ) of 1 :
17107: LD_INT 1
17109: PPUSH
17110: LD_INT 2
17112: PPUSH
17113: CALL_OW 12
17117: PUSH
17118: LD_INT 1
17120: DOUBLE
17121: EQUAL
17122: IFTRUE 17126
17124: GO 17141
17126: POP
// SayRadio ( Kathryn , DCommandIrritation-Kathryn-1 ) ; 2 :
17127: LD_EXP 7
17131: PPUSH
17132: LD_STRING DCommandIrritation-Kathryn-1
17134: PPUSH
17135: CALL_OW 94
17139: GO 17165
17141: LD_INT 2
17143: DOUBLE
17144: EQUAL
17145: IFTRUE 17149
17147: GO 17164
17149: POP
// SayRadio ( Kathryn , DCommandIrritation-Kathryn-2 ) ; end ;
17150: LD_EXP 7
17154: PPUSH
17155: LD_STRING DCommandIrritation-Kathryn-2
17157: PPUSH
17158: CALL_OW 94
17162: GO 17165
17164: POP
// case Rand ( 1 , 2 ) of 1 :
17165: LD_INT 1
17167: PPUSH
17168: LD_INT 2
17170: PPUSH
17171: CALL_OW 12
17175: PUSH
17176: LD_INT 1
17178: DOUBLE
17179: EQUAL
17180: IFTRUE 17184
17182: GO 17199
17184: POP
// Say ( Simone , DCommandIrritation-Simone-1 ) ; 2 :
17185: LD_EXP 6
17189: PPUSH
17190: LD_STRING DCommandIrritation-Simone-1
17192: PPUSH
17193: CALL_OW 88
17197: GO 17223
17199: LD_INT 2
17201: DOUBLE
17202: EQUAL
17203: IFTRUE 17207
17205: GO 17222
17207: POP
// Say ( Simone , DCommandIrritation-Simone-2 ) ; end ;
17208: LD_EXP 6
17212: PPUSH
17213: LD_STRING DCommandIrritation-Simone-2
17215: PPUSH
17216: CALL_OW 88
17220: GO 17223
17222: POP
// SayRadio ( Kathryn , DCommandIrritation-Kathryn-3 ) ;
17223: LD_EXP 7
17227: PPUSH
17228: LD_STRING DCommandIrritation-Kathryn-3
17230: PPUSH
17231: CALL_OW 94
// Say ( Simone , DCommandIrritation-Simone-3 ) ;
17235: LD_EXP 6
17239: PPUSH
17240: LD_STRING DCommandIrritation-Simone-3
17242: PPUSH
17243: CALL_OW 88
// DialogueOff ;
17247: CALL_OW 7
// end ;
17251: END
// every 0 0$1 trigger KathrynStatus = 2 do
17252: LD_EXP 46
17256: PUSH
17257: LD_INT 2
17259: EQUAL
17260: IFFALSE 17277
17262: GO 17264
17264: DISABLE
// begin SayRadio ( Kathryn , DCommandAccomplished-Kathryn-1 ) ;
17265: LD_EXP 7
17269: PPUSH
17270: LD_STRING DCommandAccomplished-Kathryn-1
17272: PPUSH
17273: CALL_OW 94
// end ;
17277: END
// every 0 0$1 trigger KathrynStatus = 3 do
17278: LD_EXP 46
17282: PUSH
17283: LD_INT 3
17285: EQUAL
17286: IFFALSE 17303
17288: GO 17290
17290: DISABLE
// begin SayRadio ( Kathryn , DCommandAccomplished-Kathryn-2 ) ;
17291: LD_EXP 7
17295: PPUSH
17296: LD_STRING DCommandAccomplished-Kathryn-2
17298: PPUSH
17299: CALL_OW 94
// end ;
17303: END
// every 0 0$1 trigger KathrynStatus = 4 do
17304: LD_EXP 46
17308: PUSH
17309: LD_INT 4
17311: EQUAL
17312: IFFALSE 17329
17314: GO 17316
17316: DISABLE
// begin SayRadio ( Kathryn , DCommandAccomplished-Kathryn-3 ) ;
17317: LD_EXP 7
17321: PPUSH
17322: LD_STRING DCommandAccomplished-Kathryn-3
17324: PPUSH
17325: CALL_OW 94
// end ;
17329: END
